<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>quiz-editor</title>
    <link rel="stylesheet" href="./css/tailwind.css" />
    <link href="./css/css2.css" rel="stylesheet" />
    <style>
      body {
        font-family: "Tajawal", sans-serif;
      }
      .rte-content[data-placeholder]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af; /* text-gray-400 */
        cursor: text;
      }
    </style>
    <script src="./js/react.production.min.js"></script>
    <script src="./js/react-dom.production.min.js"></script>

    <!-- FIX: Replaced inlined, potentially corrupt docx.js with a stable CDN version -->
    <script src="./js/index.umd.js"></script>
    <script src="./js/babel.min.js"></script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
      // =============================================
      // All Application Files Bundled Here for Babel Standalone
      // =============================================

      // ======== FROM: types.ts ========
      // NOTE: Interfaces and types are stripped by Babel but useful for development context.
      // All 'export' keywords are removed.

      /*
      type QuestionType = 'multiple-choice' | 'fill-in-the-blank' | 'true-false' | 'short-answer' | 'matching' | 'ordering' | 'connecting-lines';

      interface MediaContent {
        text: string;
        image: string | null;
      }

      interface ReadingContent extends MediaContent {
        audio: string | null;
      }

      interface Option extends MediaContent {}

      interface Pair {
        prompt: MediaContent;
        answer: MediaContent;
      }

      interface Item extends MediaContent {}

      interface BaseQuestion {
        type: QuestionType;
        reading: ReadingContent;
        question: MediaContent;
        feedback: string;
      }

      interface MultipleChoiceQuestion extends BaseQuestion {
        type: 'multiple-choice';
        options: Option[];
        correct: number;
      }

      interface FillInTheBlankQuestion extends BaseQuestion {
        type: 'fill-in-the-blank';
        correctAnswer: string;
      }

      interface TrueFalseQuestion extends BaseQuestion {
        type: 'true-false';
        correctAnswer: boolean;
      }

      interface ShortAnswerQuestion extends BaseQuestion {
        type: 'short-answer';
        correctAnswer: string;
      }

      interface MatchingQuestion extends BaseQuestion {
        type: 'matching' | 'connecting-lines';
        pairs: Pair[];
        prompts?: MediaContent[]; // For export compatibility
        answers?: MediaContent[]; // For export compatibility
      }

      interface OrderingQuestion extends BaseQuestion {
        type: 'ordering';
        items: Item[];
      }

      type Question =
        | MultipleChoiceQuestion
        | FillInTheBlankQuestion
        | TrueFalseQuestion
        | ShortAnswerQuestion
        | MatchingQuestion
        | OrderingQuestion;

      type DisplayQuestion = Question & {
        originalIndex: number;
      };

      interface AppState {
        questions: Question[];
        currentQuestionIndex: number;
      }

      interface ExportOptions {
          headerText: string;
          includeQuestionNumbers: boolean;
          includeAnswers: boolean;
          randomizeOrderItems: boolean;
          forceRtl: boolean;
          questionPerPage: boolean;
      }
      */

      // ======== FROM: services/db.ts ========
      const DB_NAME = "QuizEditorDB";
      const DB_VERSION = 5;
      const STORE_NAME = "state";
      const KEY = "appState";

      let dbPromise = null;

      const getDb = () => {
        if (dbPromise) {
          return dbPromise;
        }
        dbPromise = new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = () => {
            console.error("IndexedDB error:", request.error);
            reject("IndexedDB error");
          };
          request.onsuccess = () => {
            resolve(request.result);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME);
            }
          };
        });
        return dbPromise;
      };

      const dbGet = async () => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get(KEY);
          request.onsuccess = () => {
            resolve(request.result);
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      const dbSet = async (value) => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(value, KEY);
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      const dbClear = async () => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(KEY);
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      // ======== FROM: utils/quizUtils.ts ========
      const stripHtml = (html) => {
        if (!html) return "";
        const doc = new DOMParser().parseFromString(html, "text/html");
        return doc.body.textContent || "";
      };

      const moveItem = (array, fromIndex, toIndex) => {
        if (
          fromIndex < 0 ||
          fromIndex >= array.length ||
          toIndex < 0 ||
          toIndex >= array.length
        ) {
          return array;
        }
        const newArray = [...array];
        const [movedItem] = newArray.splice(fromIndex, 1);
        newArray.splice(toIndex, 0, movedItem);
        return newArray;
      };

      const ensureQuestionSanity = (q) => {
        const baseQuestion = {
          type: q.type || "multiple-choice",
          reading: q.reading || { text: "", image: null, audio: null },
          question: q.question || { text: "", image: null },
          feedback: q.feedback || "",
        };

        switch (baseQuestion.type) {
          case "multiple-choice": {
            const typedQ = q;
            const options = (typedQ.options || []).map((opt) => ({
              text: "",
              image: null,
              ...opt,
            }));
            return {
              ...baseQuestion,
              type: "multiple-choice",
              options: options,
              correct: typedQ.correct || 0,
            };
          }
          case "fill-in-the-blank":
            return {
              ...baseQuestion,
              type: "fill-in-the-blank",
              correctAnswer: q.correctAnswer || "",
            };
          case "true-false":
            return {
              ...baseQuestion,
              type: "true-false",
              correctAnswer: q.correctAnswer === false ? false : true,
            };
          case "short-answer":
            return {
              ...baseQuestion,
              type: "short-answer",
              correctAnswer: q.correctAnswer || "",
            };
          case "connecting-lines":
          case "matching": {
            const typedQ = q;
            const prompts = Array.isArray(typedQ.prompts) ? typedQ.prompts : [];
            const answers = Array.isArray(typedQ.answers) ? typedQ.answers : [];
            let pairs = Array.isArray(typedQ.pairs) ? typedQ.pairs : [];

            if (prompts.length > 0 && pairs.length === 0) {
              pairs = prompts.map((p, i) => ({
                prompt: p || { text: "", image: null },
                answer: answers[i] || { text: "", image: null },
              }));
            }

            return {
              ...baseQuestion,
              type: baseQuestion.type,
              pairs: pairs.map((p) => ({
                prompt: { text: "", image: null, ...p.prompt },
                answer: { text: "", image: null, ...p.answer },
              })),
            };
          }
          case "ordering": {
            const items = Array.isArray(q.items) ? q.items : [];
            const sanitizedItems = items.map((item) =>
              typeof item === "string"
                ? { text: item, image: null }
                : item || { text: "", image: null }
            );
            return {
              ...baseQuestion,
              type: "ordering",
              items: sanitizedItems,
            };
          }
          default:
            return ensureQuestionSanity({ type: "multiple-choice" });
        }
      };

      // ======== FROM: components/Icons.tsx ========
      const UploadIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      );
      const DownloadIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </svg>
      );
      const PlusIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <line x1="12" y1="5" x2="12" y2="19" />
          <line x1="5" y1="12" x2="19" y2="12" />
        </svg>
      );
      const TrashIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <polyline points="3 6 5 6 21 6" />
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
        </svg>
      );
      const Edit = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
        </svg>
      );
      const Copy = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
          <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
        </svg>
      );
      const Plus = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M5 12h14" />
          <path d="M12 5v14" />
        </svg>
      );
      const Trash2 = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M3 6h18" />
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
          <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
          <line x1="10" x2="10" y1="11" y2="17" />
          <line x1="14" x2="14" y1="11" y2="17" />
        </svg>
      );
      const GripVertical = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <circle cx="9" cy="12" r="1" />
          <circle cx="9" cy="5" r="1" />
          <circle cx="9" cy="19" r="1" />
          <circle cx="15" cy="12" r="1" />
          <circle cx="15" cy="5" r="1" />
          <circle cx="15" cy="19" r="1" />
        </svg>
      );
      const ImageUp = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L13 16" />
          <path d="m17 22 5-5" />
          <path d="M22 22h-5v-5" />
          <circle cx="9" cy="9" r="2" />
        </svg>
      );
      const ClipboardPaste = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M15 2H9a2 2 0 0 0-2 2v2H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-2V4a2 2 0 0 0-2-2Z" />
          <path d="M9 2v4h6V2" />
          <path d="M12 12v6" />
          <path d="m15 15-3 3-3-3" />
        </svg>
      );
      const AudioLines = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M2 10v3" />
          <path d="M6 6v11" />
          <path d="M10 3v18" />
          <path d="M14 8v7" />
          <path d="M18 5v13" />
          <path d="M22 10v3" />
        </svg>
      );
      const Save = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
          <polyline points="17 21 17 13 7 13 7 21" />
          <polyline points="7 3 7 8 15 8" />
        </svg>
      );
      const PlusCircle = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <circle cx="12" cy="12" r="10" />
          <path d="M8 12h8" />
          <path d="M12 8v8" />
        </svg>
      );
      const RemoveFormattingIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M4 7V4h16v3" />
          <path d="M5 20h14" />
          <path d="M12 4v16" />
          <path d="m16 12-3.515 3.515a2.12 2.12 0 0 1-3.02 0L8 14" />
          <path d="m18 9-1.5-1.5" />
          <path d="m6 9 1.5-1.5" />
          <path d="m15 6-1-1" />
          <path d="m9 6 1-1" />
          <path d="m12 20 1-1" />
          <path d="m12 20-1-1" />
        </svg>
      );
      const FileTextIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
      );

      // ======== FROM: components/RichTextEditor.tsx ========
      const RichTextEditor = ({ value, onChange, placeholder, height }) => {
        const editorRef = React.useRef(null);

        React.useEffect(() => {
          if (editorRef.current && value !== editorRef.current.innerHTML) {
            editorRef.current.innerHTML = value || "";
          }
        }, [value]);

        const handleInput = (e) => {
          onChange(e.target.innerHTML);
        };

        const handleCommand = (command, val = null) => {
          document.execCommand(command, false, val);
          if (editorRef.current) {
            editorRef.current.focus();
            onChange(editorRef.current.innerHTML);
          }
        };

        return (
          <div className="border rounded-md bg-white">
            <div className="flex items-center gap-2 p-2 bg-gray-100 border-b rounded-t-md flex-wrap">
              <button
                type="button"
                onClick={() => handleCommand("bold")}
                className="w-8 h-8 font-bold hover:bg-gray-200 rounded"
              >
                B
              </button>
              <button
                type="button"
                onClick={() => handleCommand("italic")}
                className="w-8 h-8 italic font-serif hover:bg-gray-200 rounded"
              >
                I
              </button>
              <button
                type="button"
                onClick={() => handleCommand("underline")}
                className="w-8 h-8 underline hover:bg-gray-200 rounded"
              >
                U
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyRight")}
                className="w-8 h-8 hover:bg-gray-200 rounded flex items-center justify-center"
                title="محاذاة لليمين"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="21" y1="10" x2="7" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="21" y1="14" x2="3" y2="14"></line>
                  <line x1="21" y1="18" x2="7" y2="18"></line>
                </svg>
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyCenter")}
                className="w-8 h-8 hover:bg-gray-200 rounded flex items-center justify-center"
                title="توسيط"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="18" y1="10" x2="6" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="21" y1="14" x2="3" y2="14"></line>
                  <line x1="18" y1="18" x2="6" y2="18"></line>
                </svg>
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyLeft")}
                className="w-8 h-8 hover:bg-gray-200 rounded flex items-center justify-center"
                title="محاذاة لليسار"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="17" y1="10" x2="3" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="17" y1="14" x2="3" y2="14"></line>
                  <line x1="21" y1="18" x2="3" y2="18"></line>
                </svg>
              </button>
              <input
                type="color"
                onChange={(e) => handleCommand("foreColor", e.target.value)}
                className="w-8 h-8 p-1 border-none bg-transparent cursor-pointer"
                title="لون الخط"
              />
              <select
                onChange={(e) => {
                  if (e.target.value) {
                    handleCommand("fontSize", e.target.value);
                  }
                }}
                className="p-1 border rounded-md text-sm bg-white cursor-pointer h-8"
                title="حجم الخط"
              >
                <option value="">حجم الخط</option>
                <option value="1">صغير جداً</option>
                <option value="2">صغير</option>
                <option value="3">عادي</option>
                <option value="4">متوسط</option>
                <option value="5">كبير</option>
                <option value="6">كبير جداً</option>
                <option value="7">ضخم</option>
              </select>
              <select
                onChange={(e) => {
                  if (e.target.value) {
                    handleCommand("insertText", e.target.value);
                    e.target.value = "";
                  }
                }}
                className="p-1 border rounded-md text-sm bg-white cursor-pointer h-8"
                title="إدراج رمز"
              >
                <option value="">إدراج رمز</option>
                <option value=">">&gt;</option>
                <option value="<">&lt;</option>
                <option value="≥">≥</option>
                <option value="≤">≤</option>
                <option value="≠">≠</option>
                <option value="≈">≈</option>
                <option value="°">°</option>
                <option value="◯">◯</option>
                <option value="±">±</option>
                <option value="√">√</option>
              </select>
              <button
                type="button"
                onClick={() => handleCommand("removeFormat")}
                className="w-8 h-8 hover:bg-gray-200 rounded flex justify-center items-center"
                title="مسح التنسيق"
              >
                <RemoveFormattingIcon size={18} />
              </button>
            </div>
            <div
              ref={editorRef}
              contentEditable
              onInput={handleInput}
              className="w-full p-3 outline-none rte-content"
              style={{ minHeight: height || "112px" }}
              data-placeholder={placeholder}
            ></div>
          </div>
        );
      };

      // ======== FROM: components/MediaInput.tsx ========
      const MediaInput = ({
        label,
        image,
        onImageChange,
        audio,
        onAudioChange,
      }) => {
        const imageInputRef = React.useRef(null);
        const audioInputRef = React.useRef(null);

        const handleFileChange = (e, setter) => {
          const file = e.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => setter(event.target?.result);
            reader.readAsDataURL(file);
          }
          e.target.value = "";
        };

        const handlePaste = async (setter) => {
          try {
            const items = await navigator.clipboard.read();
            const imageItem = items.find((item) =>
              item.types.some((t) => t.startsWith("image/"))
            );
            if (imageItem) {
              const type = imageItem.types.find((t) => t.startsWith("image/"));
              if (!type) {
                alert("نوع الصورة غير مدعوم.");
                return;
              }
              const blob = await imageItem.getType(type);
              const reader = new FileReader();
              reader.onload = (e) => setter(e.target?.result);
              reader.readAsDataURL(blob);
            } else {
              alert("لا توجد صورة في الحافظة.");
            }
          } catch (err) {
            console.error("Paste error:", err);
            alert(
              "فشل لصق الصورة. قد تحتاج إلى منح الإذن بالوصول إلى الحافظة."
            );
          }
        };

        return (
          <div className="space-y-2">
            {label && <h3 className="font-semibold text-gray-700">{label}</h3>}
            <div className="flex items-center gap-2 flex-wrap">
              <button
                type="button"
                onClick={() => imageInputRef.current?.click()}
                className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
              >
                <ImageUp size={16} /> صورة
              </button>
              <input
                type="file"
                ref={imageInputRef}
                onChange={(e) => handleFileChange(e, onImageChange)}
                accept="image/*"
                className="hidden"
              />
              <button
                type="button"
                onClick={() => handlePaste(onImageChange)}
                className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
              >
                <ClipboardPaste size={16} /> لصق
              </button>
              {image && (
                <button
                  type="button"
                  onClick={() => onImageChange(null)}
                  className="flex items-center gap-2 text-sm bg-red-100 text-red-600 hover:bg-red-200 px-3 py-1.5 rounded-md transition-colors"
                >
                  <Trash2 size={16} /> حذف
                </button>
              )}
            </div>
            {image && (
              <img
                src={image}
                alt="معاينة"
                className="mt-2 rounded-lg border-2 border-dashed border-gray-300 p-1 max-h-40 object-contain"
              />
            )}
            {onAudioChange && (
              <>
                <div className="flex items-center gap-2">
                  <button
                    type="button"
                    onClick={() => audioInputRef.current?.click()}
                    className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
                  >
                    <AudioLines size={16} /> صوت
                  </button>
                  <input
                    type="file"
                    ref={audioInputRef}
                    onChange={(e) => handleFileChange(e, onAudioChange)}
                    accept="audio/*"
                    className="hidden"
                  />
                  {audio && (
                    <button
                      type="button"
                      onClick={() => onAudioChange(null)}
                      className="flex items-center gap-2 text-sm bg-red-100 text-red-600 hover:bg-red-200 px-3 py-1.5 rounded-md transition-colors"
                    >
                      <Trash2 size={16} /> حذف
                    </button>
                  )}
                </div>
                {audio && (
                  <audio src={audio} controls className="mt-2 w-full" />
                )}
              </>
            )}
          </div>
        );
      };

      // ======== FROM: components/PreviewModal.tsx ========
      const PreviewModal = ({ question, onClose }) => {
        if (!question) return null;

        const renderContent = (content) => {
          if (!content) return null;
          return (
            <div
              dangerouslySetInnerHTML={{ __html: content }}
              className="prose max-w-none"
            />
          );
        };

        const renderMedia = (media) => {
          if (!media) return null;
          return (
            <img
              src={media}
              alt="معاينة الصورة"
              className="mt-4 rounded-lg max-w-full h-auto max-h-80 object-contain"
            />
          );
        };

        const renderQuestionBody = () => {
          switch (question.type) {
            case "multiple-choice":
              const mcq = question;
              return (
                <div className="grid grid-cols-2 gap-3 mt-4">
                  {(mcq.options || []).map((opt, i) => (
                    <div
                      key={i}
                      className="p-4 border rounded-lg bg-white flex flex-col items-center justify-center text-center min-h-[120px]"
                    >
                      {opt.image && (
                        <img
                          src={opt.image}
                          className="max-h-24 mb-2 object-contain"
                        />
                      )}
                      {renderContent(opt.text)}
                    </div>
                  ))}
                </div>
              );
            case "true-false":
              return (
                <div className="grid grid-cols-2 gap-3 mt-4">
                  <div className="p-4 border rounded-lg bg-white flex items-center justify-center text-center min-h-[120px] font-bold text-lg">
                    صح
                  </div>
                  <div className="p-4 border rounded-lg bg-white flex items-center justify-center text-center min-h-[120px] font-bold text-lg">
                    خطأ
                  </div>
                </div>
              );
            case "matching":
            case "connecting-lines":
              const matchQ = question;
              return (
                <div className="flex justify-between gap-4 mt-4">
                  <div className="w-1/2 space-y-3">
                    {(matchQ.pairs || []).map((p, i) => (
                      <div
                        key={`prompt-${i}`}
                        className="p-3 border rounded-lg bg-gray-100 flex flex-col items-center text-center"
                      >
                        {p.prompt.image && (
                          <img
                            src={p.prompt.image}
                            className="max-h-32 mb-2 mx-auto object-contain"
                          />
                        )}
                        {renderContent(p.prompt.text)}
                      </div>
                    ))}
                  </div>
                  <div className="w-1/2 space-y-3">
                    {(matchQ.pairs || []).map((p, i) => (
                      <div
                        key={`answer-${i}`}
                        className="p-3 border rounded-lg bg-white flex flex-col items-center text-center"
                      >
                        {p.answer.image && (
                          <img
                            src={p.answer.image}
                            className="max-h-32 mb-2 mx-auto object-contain"
                          />
                        )}
                        {renderContent(p.answer.text)}
                      </div>
                    ))}
                  </div>
                </div>
              );
            case "ordering":
              const orderQ = question;
              return (
                <div className="space-y-3 mt-4">
                  {(orderQ.items || []).map((item, i) => (
                    <div
                      key={i}
                      className="p-3 border rounded-lg bg-white flex items-center gap-4"
                    >
                      <span className="text-gray-400">☰</span>
                      {item.image && (
                        <img
                          src={item.image}
                          className="max-h-32 object-contain"
                        />
                      )}
                      {renderContent(item.text)}
                    </div>
                  ))}
                </div>
              );
            default:
              return (
                <div className="mt-4 p-4 border-2 border-dashed rounded-lg text-center text-gray-500">
                  معاينة هذا النوع من الأسئلة غير متاحة بعد.
                </div>
              );
          }
        };

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
            onClick={onClose}
          >
            <div
              className="bg-gray-100 rounded-xl shadow-2xl w-full max-w-3xl max-h-[90vh] overflow-y-auto p-6 relative"
              onClick={(e) => e.stopPropagation()}
            >
              <button
                onClick={onClose}
                className="absolute top-3 left-3 bg-gray-200 text-gray-700 rounded-full w-8 h-8 flex items-center justify-center hover:bg-red-500 hover:text-white transition-colors"
              >
                &times;
              </button>
              <h2 className="text-2xl font-bold text-blue-600 mb-4 text-center">
                معاينة السؤال
              </h2>
              {question.reading?.text && (
                <div className="p-4 mb-4 bg-white border rounded-lg">
                  {renderContent(question.reading.text)}
                </div>
              )}
              {question.reading?.image && renderMedia(question.reading.image)}
              <div className="p-4 bg-white border rounded-lg">
                <div className="font-bold text-xl mb-2">
                  {renderContent(question.question.text)}
                </div>
                {renderMedia(question.question.image)}
                {renderQuestionBody()}
              </div>
            </div>
          </div>
        );
      };

      // ======== FROM: components/QuestionList.tsx ========
      const questionTypeMapForList = {
        "multiple-choice": "اختيار من متعدد",
        "fill-in-the-blank": "املأ الفراغ",
        "true-false": "صح/خطأ",
        "short-answer": "إجابة قصيرة",
        matching: "مطابقة",
        ordering: "ترتيب",
        "connecting-lines": "توصيل",
      };

      const QuestionList = ({
        questions,
        currentQuestionIndex,
        onSelectQuestion,
        onDeleteQuestion,
        onDuplicateQuestion,
        onAddNewQuestion,
        onDragStart,
        onDrop,
        filterType,
        onFilterChange,
        searchTerm,
        onSearchChange,
      }) => {
        const [dragOverIndex, setDragOverIndex] = React.useState(null);

        const handleDragOver = (e, index) => {
          e.preventDefault();
          setDragOverIndex(index);
        };

        return (
          <div className="bg-white p-4 rounded-xl shadow-md sticky top-6">
            <div className="text-center border-b pb-3 mb-3">
              <h3 className="text-xl font-bold text-gray-800">
                قائمة الأسئلة ({questions.length})
              </h3>
              <p className="text-sm text-gray-500">اسحب وأفلت لإعادة الترتيب</p>
            </div>
            <div className="p-2 space-y-3">
              <input
                type="text"
                placeholder="ابحث في نص السؤال..."
                value={searchTerm}
                onChange={(e) => onSearchChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white text-sm"
              />
              <select
                value={filterType}
                onChange={(e) => onFilterChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white text-sm"
              >
                <option value="all">كل أنواع الأسئلة</option>
                {Object.entries(questionTypeMapForList).map(([key, value]) => (
                  <option key={key} value={key}>
                    {value}
                  </option>
                ))}
              </select>
            </div>
            <ul className="space-y-2 max-h-[75vh] overflow-y-auto pr-2">
              {questions.map((q, index) => {
                const originalIndex = q.originalIndex;
                const isActive = originalIndex === currentQuestionIndex;
                const previewText =
                  stripHtml(q.question.text || "سؤال فارغ").substring(0, 50) +
                  "...";
                return (
                  <li
                    key={originalIndex}
                    draggable
                    onDragStart={() => onDragStart(originalIndex)}
                    onDragOver={(e) => handleDragOver(e, index)}
                    onDragLeave={() => setDragOverIndex(null)}
                    onDrop={() => {
                      onDrop(originalIndex);
                      setDragOverIndex(null);
                    }}
                    className={`p-3 rounded-lg border-2 transition-all duration-200 cursor-pointer group ${
                      isActive
                        ? "bg-blue-100 border-blue-500 shadow-md"
                        : "bg-gray-50 border-gray-200 hover:border-blue-300 hover:bg-blue-50"
                    } ${
                      dragOverIndex === index
                        ? "transform scale-105 bg-blue-200"
                        : ""
                    }`}
                  >
                    <div className="flex items-start gap-2">
                      <div className="flex-shrink-0 cursor-grab text-gray-400 group-hover:text-gray-600 pt-1">
                        <GripVertical />
                      </div>
                      <div
                        className="flex-grow"
                        onClick={() => onSelectQuestion(originalIndex)}
                      >
                        <div className="flex justify-between items-center">
                          <span className="font-bold text-gray-800">
                            السؤال {originalIndex + 1}
                          </span>
                          <span className="text-xs bg-gray-200 text-gray-600 px-2 py-0.5 rounded-full">
                            {questionTypeMapForList[q.type]}
                          </span>
                        </div>
                        <p className="text-sm text-gray-600 mt-1">
                          {previewText}
                        </p>
                      </div>
                    </div>
                    <div className="flex justify-end gap-2 mt-2 pt-2 border-t border-gray-200">
                      <button
                        title="تعديل"
                        onClick={() => onSelectQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-blue-600 rounded-full hover:bg-blue-100"
                      >
                        <Edit size={16} />
                      </button>
                      <button
                        title="نسخ"
                        onClick={() => onDuplicateQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-green-600 rounded-full hover:bg-green-100"
                      >
                        <Copy size={16} />
                      </button>
                      <button
                        title="إدراج سؤال"
                        onClick={() => onAddNewQuestion(originalIndex + 1)}
                        className="p-1.5 text-gray-500 hover:text-indigo-600 rounded-full hover:bg-indigo-100"
                      >
                        <Plus size={16} />
                      </button>
                      <button
                        title="حذف"
                        onClick={() => onDeleteQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-red-600 rounded-full hover:bg-red-100"
                      >
                        <Trash2 size={16} />
                      </button>
                    </div>
                  </li>
                );
              })}
            </ul>
          </div>
        );
      };

      // ======== FROM: components/ExportOptionsModal.tsx ========
      const ExportOptionsModal = ({ isOpen, onClose, onConfirm }) => {
        const [options, setOptions] = React.useState({
          headerText: "",
          includeQuestionNumbers: true,
          includeAnswers: false,
          randomizeOrderItems: true,
          forceRtl: true,
          questionPerPage: true,
        });

        if (!isOpen) return null;

        const handleConfirm = () => {
          onConfirm(options);
        };

        const handleCheckboxChange = (e) => {
          const { name, checked } = e.target;
          setOptions((prev) => ({ ...prev, [name]: checked }));
        };

        const handleTextChange = (e) => {
          const { name, value } = e.target;
          setOptions((prev) => ({ ...prev, [name]: value }));
        };

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
            onClick={onClose}
          >
            <div
              className="bg-white rounded-xl shadow-2xl w-full max-w-md p-6 relative"
              onClick={(e) => e.stopPropagation()}
            >
              <button
                onClick={onClose}
                className="absolute top-3 left-3 bg-gray-200 text-gray-700 rounded-full w-8 h-8 flex items-center justify-center hover:bg-red-500 hover:text-white transition-colors"
              >
                &times;
              </button>
              <h2 className="text-2xl font-bold text-blue-600 mb-6 text-center">
                خيارات تصدير Word
              </h2>

              <div className="space-y-4">
                <div>
                  <label
                    htmlFor="headerText"
                    className="block text-md font-medium text-gray-700 mb-2"
                  >
                    عنوان المستند (اختياري)
                  </label>
                  <textarea
                    id="headerText"
                    name="headerText"
                    value={options.headerText}
                    onChange={handleTextChange}
                    rows={3}
                    className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
                    placeholder="السطر 1: اسم الاختبار&#10;السطر 2: اسم الطالب: ..........&#10;السطر 3: الصف: .........."
                  />
                </div>

                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      id="includeQuestionNumbers"
                      name="includeQuestionNumbers"
                      type="checkbox"
                      checked={options.includeQuestionNumbers}
                      onChange={handleCheckboxChange}
                      className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                    />
                  </div>
                  <div className="mr-3 text-sm">
                    <label
                      htmlFor="includeQuestionNumbers"
                      className="font-medium text-gray-700"
                    >
                      تضمين أرقام الأسئلة
                    </label>
                    <p className="text-gray-500">
                      عرض "السؤال 1:"، "السؤال 2:"، إلخ.
                    </p>
                  </div>
                </div>

                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      id="includeAnswers"
                      name="includeAnswers"
                      type="checkbox"
                      checked={options.includeAnswers}
                      onChange={handleCheckboxChange}
                      className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                    />
                  </div>
                  <div className="mr-3 text-sm">
                    <label
                      htmlFor="includeAnswers"
                      className="font-medium text-gray-700"
                    >
                      تضمين الإجابات النموذجية
                    </label>
                    <p className="text-gray-500">لإنشاء نسخة خاصة بالمعلم.</p>
                  </div>
                </div>

                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      id="randomizeOrderItems"
                      name="randomizeOrderItems"
                      type="checkbox"
                      checked={options.randomizeOrderItems}
                      onChange={handleCheckboxChange}
                      className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                      disabled={options.includeAnswers}
                    />
                  </div>
                  <div className="mr-3 text-sm">
                    <label
                      htmlFor="randomizeOrderItems"
                      className={`font-medium ${
                        options.includeAnswers
                          ? "text-gray-400"
                          : "text-gray-700"
                      }`}
                    >
                      ترتيب عشوائي لعناصر سؤال الترتيب
                    </label>
                    <p
                      className={
                        options.includeAnswers
                          ? "text-gray-400"
                          : "text-gray-500"
                      }
                    >
                      يتم تعطيل هذا الخيار عند تضمين الإجابات.
                    </p>
                  </div>
                </div>

                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      id="forceRtl"
                      name="forceRtl"
                      type="checkbox"
                      checked={options.forceRtl}
                      onChange={handleCheckboxChange}
                      className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                    />
                  </div>
                  <div className="mr-3 text-sm">
                    <label
                      htmlFor="forceRtl"
                      className="font-medium text-gray-700"
                    >
                      فرض اتجاه المستند من اليمين لليسار
                    </label>
                    <p className="text-gray-500">
                      لضمان التوافق الكامل مع اللغة العربية.
                    </p>
                  </div>
                </div>

                <div className="relative flex items-start">
                  <div className="flex items-center h-5">
                    <input
                      id="questionPerPage"
                      name="questionPerPage"
                      type="checkbox"
                      checked={options.questionPerPage}
                      onChange={handleCheckboxChange}
                      className="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300 rounded"
                    />
                  </div>
                  <div className="mr-3 text-sm">
                    <label
                      htmlFor="questionPerPage"
                      className="font-medium text-gray-700"
                    >
                      وضع كل سؤال في صفحة مستقلة
                    </label>
                    <p className="text-gray-500">
                      عند إلغاء التفعيل، ستكون الأسئلة متتالية.
                    </p>
                  </div>
                </div>
              </div>

              <div className="mt-8 flex justify-center gap-4">
                <button
                  onClick={handleConfirm}
                  className="flex items-center gap-2 bg-sky-500 text-white font-semibold py-2 px-6 rounded-lg hover:bg-sky-600 transition-colors shadow"
                >
                  تأكيد التصدير
                </button>
                <button
                  onClick={onClose}
                  className="py-2 px-6 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors"
                >
                  إلغاء
                </button>
              </div>
            </div>
          </div>
        );
      };

      // ======== FROM: services/exportService.ts ========
      const MAX_IMAGE_WIDTH = 450;

      const processBase64Image = async (base64) => {
        if (!base64) return null;

        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            let { width, height } = img;
            if (width > MAX_IMAGE_WIDTH) {
              const ratio = MAX_IMAGE_WIDTH / width;
              width = MAX_IMAGE_WIDTH;
              height *= ratio;
            }

            const byteString = atob(base64.split(",")[1]);
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
              ia[i] = byteString.charCodeAt(i);
            }
            resolve({ data: ab, width, height });
          };
          img.onerror = () => resolve(null);
          img.src = base64;
        });
      };

      const createMediaContentParagraphs = async (content, docx, alignment) => {
        const { Paragraph, TextRun, ImageRun } = docx;
        const paragraphs = [];
        const strippedText = stripHtml(content.text);
        if (strippedText) {
          paragraphs.push(
            new Paragraph({
              children: [new TextRun(strippedText)],
              alignment: alignment,
              rightToLeft: true,
              style: "Normal",
            })
          );
        }
        if (content.image) {
          const imgData = await processBase64Image(content.image);
          if (imgData) {
            paragraphs.push(
              new Paragraph({
                children: [
                  new ImageRun({
                    data: imgData.data,
                    transformation: {
                      width: imgData.width,
                      height: imgData.height,
                    },
                  }),
                ],
                alignment: docx.AlignmentType.CENTER,
                style: "Normal",
              })
            );
          }
        }
        return paragraphs;
      };

      const exportQuestionsToWord = async (questions, options) => {
        const docx = window.docx;
        if (!docx) {
          alert(
            "مكتبة تصدير Word غير متاحة. يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى."
          );
          console.error(
            "The 'docx' library is not available on the window object."
          );
          return;
        }

        const {
          Document,
          Packer,
          Paragraph,
          TextRun,
          Table,
          TableRow,
          TableCell,
          WidthType,
          HeadingLevel,
          AlignmentType,
          PageBreak,
          VerticalAlign,
        } = docx;

        const children = [];

        if (options.headerText.trim()) {
          const headerLines = options.headerText.trim().split("\n");
          for (const line of headerLines) {
            children.push(
              new Paragraph({
                text: line,
                alignment: AlignmentType.CENTER,
                rightToLeft: true,
                style: "Normal",
              })
            );
          }
          children.push(new Paragraph({ text: "", style: "Normal" }));
        }

        for (const [index, question] of questions.entries()) {
          let questionHeader = "";
          if (options.includeQuestionNumbers) {
            questionHeader = `السؤال ${index + 1}:`;
          }

          children.push(
            new Paragraph({
              text: questionHeader,
              heading: HeadingLevel.HEADING_2,
              alignment: AlignmentType.RIGHT,
              rightToLeft: true,
            })
          );

          if (stripHtml(question.reading.text) || question.reading.image) {
            children.push(
              new Paragraph({
                children: [new TextRun({ text: "النص القرائي:", bold: true })],
                alignment: AlignmentType.RIGHT,
                rightToLeft: true,
                style: "Normal",
              })
            );
            children.push(
              ...(await createMediaContentParagraphs(
                question.reading,
                docx,
                AlignmentType.RIGHT
              ))
            );
          }

          children.push(
            ...(await createMediaContentParagraphs(
              question.question,
              docx,
              AlignmentType.RIGHT
            ))
          );

          switch (question.type) {
            case "multiple-choice": {
              const mcq = question;
              for (const [optIndex, option] of mcq.options.entries()) {
                const isCorrect =
                  options.includeAnswers && optIndex === mcq.correct;
                const text = `${String.fromCharCode(
                  0x0627 + optIndex
                )}) ${stripHtml(option.text)} ${
                  isCorrect ? "(الإجابة الصحيحة)" : ""
                }`;
                const p = new Paragraph({
                  children: [new TextRun(text)],
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                  indent: { right: 360 },
                });
                children.push(p);
                if (option.image) {
                  children.push(
                    ...(await createMediaContentParagraphs(
                      { text: "", image: option.image },
                      docx,
                      AlignmentType.RIGHT
                    ))
                  );
                }
              }
              break;
            }
            case "true-false": {
              children.push(
                new Paragraph({
                  text: `\nضع علامة (صح) أو (خطأ) أمام العبارة.`,
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                })
              );
              if (options.includeAnswers) {
                const tfq = question;
                children.push(
                  new Paragraph({
                    text: `الإجابة الصحيحة: ${
                      tfq.correctAnswer ? "صح" : "خطأ"
                    }`,
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "strong",
                  })
                );
              }
              break;
            }
            case "fill-in-the-blank": {
              children.push(
                new Paragraph({
                  text: `........................................`,
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                })
              );
              if (options.includeAnswers) {
                const fitb = question;
                children.push(
                  new Paragraph({
                    text: `الإجابة الصحيحة: ${fitb.correctAnswer}`,
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "strong",
                  })
                );
              }
              break;
            }
            case "short-answer": {
              children.push(
                new Paragraph({
                  text: `........................................`,
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                })
              );
              if (options.includeAnswers) {
                const saq = question;
                children.push(
                  new Paragraph({
                    text: `الإجابات المحتملة: ${saq.correctAnswer}`,
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "strong",
                  })
                );
              }
              break;
            }
            case "ordering": {
              const oq = question;
              children.push(
                new Paragraph({
                  text: "رتب العناصر التالية بالترتيب الصحيح:",
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                })
              );

              let itemsToRender = [...oq.items];

              if (!options.includeAnswers && options.randomizeOrderItems) {
                for (let i = itemsToRender.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [itemsToRender[i], itemsToRender[j]] = [
                    itemsToRender[j],
                    itemsToRender[i],
                  ];
                }
              }

              if (!options.includeAnswers) {
                for (const item of itemsToRender) {
                  const text = `(.....) ${stripHtml(item.text)}`;
                  const p = new Paragraph({
                    children: [new TextRun(text)],
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "Normal",
                    indent: { right: 360 },
                  });
                  children.push(p);
                  if (item.image) {
                    children.push(
                      ...(await createMediaContentParagraphs(
                        { text: "", image: item.image },
                        docx,
                        AlignmentType.RIGHT
                      ))
                    );
                  }
                }
              }

              if (options.includeAnswers) {
                children.push(
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "الإجابة (الترتيب الصحيح):",
                        bold: true,
                      }),
                    ],
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "Normal",
                  })
                );
                for (const [itemIndex, item] of oq.items.entries()) {
                  const text = `${itemIndex + 1}- ${stripHtml(item.text)}`;
                  const p = new Paragraph({
                    children: [new TextRun(text)],
                    alignment: AlignmentType.RIGHT,
                    rightToLeft: true,
                    style: "Normal",
                    indent: { right: 360 },
                  });
                  children.push(p);
                  if (item.image) {
                    children.push(
                      ...(await createMediaContentParagraphs(
                        { text: "", image: item.image },
                        docx,
                        AlignmentType.RIGHT
                      ))
                    );
                  }
                }
              }
              break;
            }
            case "matching":
            case "connecting-lines": {
              const mq = question;
              const instruction =
                mq.type === "matching"
                  ? "طابق بين القائمة (أ) و ما يناسبها في القائمة (ب):"
                  : "صل بين القائمة (أ) و ما يناسبها في القائمة (ب):";
              children.push(
                new Paragraph({
                  text: instruction,
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  style: "Normal",
                })
              );

              const rows = [
                new TableRow({
                  children: [
                    new TableCell({
                      children: [
                        new Paragraph({
                          text: "القائمة (ب)",
                          alignment: AlignmentType.CENTER,
                          style: "Normal",
                        }),
                      ],
                      verticalAlign: VerticalAlign.CENTER,
                    }),
                    new TableCell({
                      children: [
                        new Paragraph({
                          text: "القائمة (أ)",
                          alignment: AlignmentType.CENTER,
                          style: "Normal",
                        }),
                      ],
                      verticalAlign: VerticalAlign.CENTER,
                    }),
                  ],
                }),
              ];

              for (const pair of mq.pairs) {
                const promptParas = await createMediaContentParagraphs(
                  pair.prompt,
                  docx,
                  AlignmentType.CENTER
                );
                const answerParas = await createMediaContentParagraphs(
                  pair.answer,
                  docx,
                  AlignmentType.CENTER
                );
                rows.push(
                  new TableRow({
                    children: [
                      new TableCell({
                        children: answerParas,
                        verticalAlign: VerticalAlign.CENTER,
                      }),
                      new TableCell({
                        children: promptParas,
                        verticalAlign: VerticalAlign.CENTER,
                      }),
                    ],
                  })
                );
              }

              const table = new Table({
                rows,
                width: { size: 100, type: WidthType.PERCENTAGE },
                rightToLeft: true,
              });
              children.push(table);
              break;
            }
          }

          if (options.questionPerPage && index < questions.length - 1) {
            children.push(new Paragraph({ children: [new PageBreak()] }));
          } else {
            children.push(new Paragraph(" ")); // Add some space between questions
          }
        }

        const doc = new Document({
          creator: "محرر الأسئلة المطور",
          title: options.headerText.trim() || "ملف أسئلة",
          description: "تم إنشاؤه بواسطة محرر الأسئلة المطور",
          sections: [
            {
              properties: {
                page: {
                  margin: { top: 720, right: 720, bottom: 720, left: 720 },
                },
                rightToLeft: options.forceRtl,
              },
              children: children,
            },
          ],
          styles: {
            default: {
              heading1: {
                run: {
                  font: "Tajawal",
                  size: 32,
                  bold: true,
                  color: "000000",
                  rtl: true,
                },
                paragraph: {
                  alignment: AlignmentType.CENTER,
                  rightToLeft: true,
                  spacing: { after: 240 },
                },
              },
              heading2: {
                run: {
                  font: "Tajawal",
                  size: 28,
                  bold: true,
                  color: "000000",
                  rtl: true,
                },
                paragraph: {
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  spacing: { after: 200, before: 200 },
                },
              },
            },
            paragraphStyles: [
              {
                id: "Normal",
                name: "Normal",
                basedOn: "Normal",
                next: "Normal",
                quickFormat: true,
                run: {
                  font: "Tajawal",
                  size: 24, // 12pt
                  rtl: true,
                },
                paragraph: {
                  alignment: AlignmentType.RIGHT,
                  rightToLeft: true,
                  spacing: { after: 120 },
                },
              },
              {
                id: "strong",
                name: "Strong",
                basedOn: "Normal",
                next: "Normal",
                quickFormat: true,
                run: { bold: true, rtl: true },
              },
            ],
          },
        });

        Packer.toBlob(doc).then((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "quiz.docx";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });
      };

      // ======== FROM: components/EditorPanel.tsx ========
      const EditorPanel = ({
        question,
        onUpdate,
        questionNumber,
        onSaveAndNew,
        onPreview,
      }) => {
        const [localQuestion, setLocalQuestion] = React.useState(question);
        const [draggedItem, setDraggedItem] = React.useState({
          type: null,
          index: -1,
        });

        React.useEffect(() => {
          setLocalQuestion(question);
        }, [question]);

        const handleChange = (key, value) => {
          setLocalQuestion((prev) => ({ ...prev, [key]: value }));
        };

        const handleNestedChange = (parentKey, childKey, value) => {
          setLocalQuestion((prev) => ({
            ...prev,
            [parentKey]: {
              ...(prev[parentKey] || {}),
              [childKey]: value,
            },
          }));
        };

        const handleTypeChange = (e) => {
          const newType = e.target.value;
          const newQuestionState = ensureQuestionSanity({
            ...localQuestion,
            type: newType,
          });
          setLocalQuestion(newQuestionState);
        };

        const handleSave = () => {
          const questionToSave = JSON.parse(JSON.stringify(localQuestion));
          const cleanHtml = (html) =>
            (html || "").replace(/(<p><br><\/p>|\s|&nbsp;)*$/, "").trim();

          questionToSave.reading.text = cleanHtml(questionToSave.reading.text);
          questionToSave.question.text = cleanHtml(
            questionToSave.question.text
          );
          questionToSave.feedback = cleanHtml(questionToSave.feedback);

          if (
            questionToSave.type === "matching" ||
            questionToSave.type === "connecting-lines"
          ) {
            const validPairs = (questionToSave.pairs || []).filter(
              (p) =>
                (p.prompt && (p.prompt.text || p.prompt.image)) ||
                (p.answer && (p.answer.text || p.answer.image))
            );
            questionToSave.pairs = validPairs;
            questionToSave.prompts = validPairs.map(
              (p) => p.prompt || { text: "", image: null }
            );
            questionToSave.answers = validPairs.map(
              (p) => p.answer || { text: "", image: null }
            );
          }

          onUpdate(questionToSave);
          return questionToSave;
        };

        const handleAddOption = () => {
          setLocalQuestion((prev) => {
            const q = prev;
            const newOptions = [
              ...(q.options || []),
              { text: "", image: null },
            ];
            return { ...q, options: newOptions };
          });
        };

        const handleOptionChange = (index, key, value) => {
          setLocalQuestion((prev) => {
            const q = prev;
            const newOptions = [...q.options];
            newOptions[index] = { ...newOptions[index], [key]: value };
            return { ...q, options: newOptions };
          });
        };

        const handleCorrectChange = (newCorrectIndex) => {
          setLocalQuestion((prev) => ({ ...prev, correct: newCorrectIndex }));
        };

        const handlePairChange = (index, part, key, value) => {
          setLocalQuestion((prev) => {
            const q = prev;
            const newPairs = JSON.parse(JSON.stringify(q.pairs || []));
            if (!newPairs[index]) newPairs[index] = { prompt: {}, answer: {} };
            if (!newPairs[index][part]) newPairs[index][part] = {};
            newPairs[index][part][key] = value;
            return { ...q, pairs: newPairs };
          });
        };

        const handleRemovePair = (index) => {
          setLocalQuestion((prev) => {
            const q = prev;
            const newPairs = q.pairs.filter((_, i) => i !== index);
            return { ...q, pairs: newPairs };
          });
        };

        const handleDragStart = (type, index) => {
          setDraggedItem({ type, index });
        };

        const handleDrop = (type, targetIndex) => {
          if (
            draggedItem.type !== type ||
            draggedItem.index === -1 ||
            draggedItem.index === targetIndex
          )
            return;

          let currentArray = localQuestion[type];
          let correctIndex = localQuestion.correct;

          if (type === "options" && localQuestion.type === "multiple-choice") {
            const mcq = localQuestion;
            const draggedOptionIsCorrect = draggedItem.index === mcq.correct;

            if (draggedOptionIsCorrect) {
              correctIndex = targetIndex;
            } else {
              if (
                draggedItem.index < mcq.correct &&
                targetIndex >= mcq.correct
              ) {
                correctIndex--;
              } else if (
                draggedItem.index > mcq.correct &&
                targetIndex <= mcq.correct
              ) {
                correctIndex++;
              }
            }
          }

          const newArray = moveItem(
            currentArray,
            draggedItem.index,
            targetIndex
          );

          setLocalQuestion((prev) => {
            const updated = {
              ...prev,
              [type]: newArray,
            };
            if (type === "options" && prev.type === "multiple-choice") {
              updated.correct = correctIndex;
            }
            return updated;
          });

          setDraggedItem({ type: null, index: -1 });
        };

        const renderEditorFields = () => {
          switch (localQuestion.type) {
            case "multiple-choice":
              const mcq = localQuestion;
              return (
                <div className="space-y-4">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      الخيارات (يجب تحديد الإجابة الصحيحة)
                    </label>
                    <button
                      type="button"
                      onClick={handleAddOption}
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة خيار
                    </button>
                  </div>
                  {(mcq.options || []).map((opt, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("options", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("options", index)}
                      className="p-3 bg-white rounded-lg border relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2 flex items-center gap-1">
                        {mcq.options.length > 2 && (
                          <button
                            type="button"
                            onClick={() => {
                              setLocalQuestion((prev) => {
                                const currentMcq = prev;
                                let newCorrect = currentMcq.correct;
                                if (index === currentMcq.correct)
                                  newCorrect = 0;
                                else if (index < currentMcq.correct)
                                  newCorrect--;
                                const newOptions = currentMcq.options.filter(
                                  (_, i) => i !== index
                                );
                                return {
                                  ...currentMcq,
                                  options: newOptions,
                                  correct: newCorrect,
                                };
                              });
                            }}
                            className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                            title="حذف الخيار"
                          >
                            <Trash2 size={16} />
                          </button>
                        )}
                      </div>
                      <div className="flex items-start gap-3 mb-2 pr-8 pl-8">
                        <input
                          type="radio"
                          name="correctOption"
                          checked={mcq.correct === index}
                          onChange={() => handleCorrectChange(index)}
                          className="form-radio h-5 w-5 text-blue-600 mt-2.5 flex-shrink-0"
                        />
                        <div className="flex-grow space-y-2">
                          <input
                            type="text"
                            placeholder={`الخيار ${index + 1}`}
                            value={opt.text}
                            onChange={(e) =>
                              handleOptionChange(index, "text", e.target.value)
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={opt.image}
                            onImageChange={(img) =>
                              handleOptionChange(index, "image", img)
                            }
                          />
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              );
            case "fill-in-the-blank":
              const fitb = localQuestion;
              return (
                <div>
                  <label
                    htmlFor="correctAnswer"
                    className="font-semibold text-lg text-gray-800"
                  >
                    الإجابة الصحيحة:
                  </label>
                  <input
                    id="correctAnswer"
                    type="text"
                    value={fitb.correctAnswer}
                    onChange={(e) =>
                      setLocalQuestion((prev) => ({
                        ...prev,
                        correctAnswer: e.target.value,
                      }))
                    }
                    className="w-full mt-2 p-2 border rounded-md"
                    placeholder="اكتب الإجابة هنا..."
                  />
                  <p className="text-sm text-gray-500 mt-2">
                    ملاحظة: يمكنك وضع عدة إجابات صحيحة بفصلها بعلامة | (مثال:
                    إجابة1|إجابة2)
                  </p>
                </div>
              );
            case "true-false":
              const tf = localQuestion;
              return (
                <div className="space-y-2">
                  <label className="font-semibold text-lg text-gray-800">
                    الإجابة الصحيحة:
                  </label>
                  <div className="flex gap-4">
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="radio"
                        name="tf-answer"
                        checked={tf.correctAnswer === true}
                        onChange={() =>
                          setLocalQuestion((prev) => ({
                            ...prev,
                            correctAnswer: true,
                          }))
                        }
                        className="form-radio h-5 w-5 text-blue-600"
                      />
                      صح
                    </label>
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="radio"
                        name="tf-answer"
                        checked={tf.correctAnswer === false}
                        onChange={() =>
                          setLocalQuestion((prev) => ({
                            ...prev,
                            correctAnswer: false,
                          }))
                        }
                        className="form-radio h-5 w-5 text-blue-600"
                      />
                      خطأ
                    </label>
                  </div>
                </div>
              );
            case "short-answer":
              const sa = localQuestion;
              return (
                <div>
                  <label
                    htmlFor="shortAnswer"
                    className="font-semibold text-lg text-gray-800"
                  >
                    الإجابات الصحيحة المحتملة:
                  </label>
                  <textarea
                    id="shortAnswer"
                    value={sa.correctAnswer}
                    onChange={(e) =>
                      setLocalQuestion((prev) => ({
                        ...prev,
                        correctAnswer: e.target.value,
                      }))
                    }
                    className="w-full mt-2 p-2 border rounded-md h-24"
                    placeholder="اكتب الإجابات هنا..."
                  />
                  <p className="text-sm text-gray-500 mt-2">
                    اكتب الإجابات الصحيحة المحتملة. افصل بين كل إجابة بعلامة | .
                    سيتم التحقق من تطابق إجابة الطالب مع أي من هذه الإجابات.
                  </p>
                </div>
              );
            case "connecting-lines":
            case "matching":
              const matchQ = localQuestion;
              const title =
                matchQ.type === "matching" ? "أزواج المطابقة" : "أزواج التوصيل";
              return (
                <div className="space-y-5">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      {title}
                    </label>
                    <button
                      type="button"
                      onClick={() =>
                        setLocalQuestion((prev) => {
                          const currentMatchQ = prev;
                          return {
                            ...currentMatchQ,
                            pairs: [
                              ...(currentMatchQ.pairs || []),
                              {
                                prompt: { text: "", image: null },
                                answer: { text: "", image: null },
                              },
                            ],
                          };
                        })
                      }
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة زوج
                    </button>
                  </div>
                  {(matchQ.pairs || []).map((pair, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("pairs", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("pairs", index)}
                      className="p-3 bg-white rounded-lg border relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 pt-6">
                        <div className="space-y-2">
                          <label className="text-sm font-medium text-gray-600">
                            العنصر {index + 1}
                          </label>
                          <input
                            type="text"
                            placeholder={`العنصر ${index + 1}`}
                            value={pair.prompt?.text || ""}
                            onChange={(e) =>
                              handlePairChange(
                                index,
                                "prompt",
                                "text",
                                e.target.value
                              )
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={pair.prompt?.image}
                            onImageChange={(img) =>
                              handlePairChange(index, "prompt", "image", img)
                            }
                          />
                        </div>
                        <div className="space-y-2">
                          <label className="text-sm font-medium text-gray-600">
                            الإجابة {index + 1}
                          </label>
                          <input
                            type="text"
                            placeholder={`الإجابة ${index + 1}`}
                            value={pair.answer?.text || ""}
                            onChange={(e) =>
                              handlePairChange(
                                index,
                                "answer",
                                "text",
                                e.target.value
                              )
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={pair.answer?.image}
                            onImageChange={(img) =>
                              handlePairChange(index, "answer", "image", img)
                            }
                          />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2">
                        <button
                          type="button"
                          onClick={() => handleRemovePair(index)}
                          className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                          title="حذف الزوج"
                        >
                          <Trash2 size={16} />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              );
            case "ordering":
              const orderQ = localQuestion;
              return (
                <div className="space-y-5">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      عناصر الترتيب (بالترتيب الصحيح):
                    </label>
                    <button
                      type="button"
                      onClick={() =>
                        setLocalQuestion((prev) => {
                          const currentOrderQ = prev;
                          return {
                            ...currentOrderQ,
                            items: [
                              ...(currentOrderQ.items || []),
                              { text: "", image: null },
                            ],
                          };
                        })
                      }
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة عنصر
                    </button>
                  </div>
                  {(orderQ.items || []).map((item, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("items", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("items", index)}
                      className="p-3 bg-white rounded-lg border space-y-2 relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-1/2 -translate-y-1/2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2">
                        <button
                          type="button"
                          onClick={() =>
                            setLocalQuestion((prev) => {
                              const currentOrderQ = prev;
                              return {
                                ...currentOrderQ,
                                items: currentOrderQ.items.filter(
                                  (_, i) => i !== index
                                ),
                              };
                            })
                          }
                          className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                          title="حذف العنصر"
                        >
                          <Trash2 size={16} />
                        </button>
                      </div>
                      <div className="pr-8">
                        <input
                          type="text"
                          placeholder={`العنصر ${index + 1} (نص)`}
                          value={item.text}
                          onChange={(e) => {
                            setLocalQuestion((prev) => {
                              const currentOrderQ = prev;
                              const newItems = [...currentOrderQ.items];
                              newItems[index] = {
                                ...newItems[index],
                                text: e.target.value,
                              };
                              return { ...currentOrderQ, items: newItems };
                            });
                          }}
                          className="w-full p-2 border rounded-md"
                        />
                        <MediaInput
                          label=""
                          image={item.image}
                          onImageChange={(img) => {
                            setLocalQuestion((prev) => {
                              const currentOrderQ = prev;
                              const newItems = [...currentOrderQ.items];
                              newItems[index] = {
                                ...newItems[index],
                                image: img,
                              };
                              return { ...currentOrderQ, items: newItems };
                            });
                          }}
                        />
                      </div>
                    </div>
                  ))}
                  <p className="text-sm text-gray-500 mt-2">
                    املأ العناصر التي تريدها بالترتيب الصحيح. يمكن أن يكون كل
                    عنصر نصًا أو صورة أو كليهما. سيتم تجاهل الحقول الفارغة. يجب
                    ملء عنصرين على الأقل.
                  </p>
                </div>
              );
            default:
              return null;
          }
        };

        return (
          <div className="bg-white p-6 rounded-xl shadow-md space-y-6">
            <h2 className="text-2xl font-bold text-blue-600 border-b pb-3">
              تحرير السؤال{" "}
              <span className="text-gray-500 font-medium">
                ({questionNumber})
              </span>
            </h2>
            <div className="p-4 bg-gray-50 rounded-lg border">
              <label
                htmlFor="questionType"
                className="font-semibold text-gray-700"
              >
                نوع السؤال:
              </label>
              <select
                id="questionType"
                value={localQuestion.type}
                onChange={handleTypeChange}
                className="w-full mt-2 p-2 border rounded-md bg-white"
              >
                <option value="multiple-choice">اختيار من متعدد</option>
                <option value="fill-in-the-blank">املأ الفراغ</option>
                <option value="true-false">صح / خطأ</option>
                <option value="short-answer">إجابة قصيرة</option>
                <option value="matching">مطابقة</option>
                <option value="ordering">ترتيب</option>
                <option value="connecting-lines">توصيل</option>
              </select>
            </div>
            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">
                النص القرائي (اختياري):
              </label>
              <RichTextEditor
                value={localQuestion.reading.text}
                onChange={(html) => handleNestedChange("reading", "text", html)}
                placeholder="اكتب النص القرائي هنا..."
              />
              <MediaInput
                label=""
                image={localQuestion.reading.image}
                onImageChange={(img) =>
                  handleNestedChange("reading", "image", img)
                }
                audio={localQuestion.reading.audio}
                onAudioChange={(aud) =>
                  handleNestedChange("reading", "audio", aud)
                }
              />
            </div>
            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">نص السؤال:</label>
              <RichTextEditor
                placeholder="اكتب السؤال هنا..."
                value={localQuestion.question.text}
                onChange={(html) =>
                  handleNestedChange("question", "text", html)
                }
                height="80px"
              />
              <MediaInput
                label=""
                image={localQuestion.question.image}
                onImageChange={(img) =>
                  handleNestedChange("question", "image", img)
                }
              />
            </div>
            <div className="p-4 bg-gray-50 rounded-lg border">
              {renderEditorFields()}
            </div>
            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">
                التغذية الراجعة (اختياري):
              </label>
              <RichTextEditor
                placeholder="اكتب هنا شرحًا للإجابة الصحيحة أو سبب خطأ الإجابات الأخرى. ستظهر هذه الرسالة للطالب بعد الإجابة."
                value={localQuestion.feedback || ""}
                onChange={(html) => handleChange("feedback", html)}
                height="96px"
              />
              <p className="text-sm text-gray-500">
                إذا تركت هذا الحقل فارغًا، فلن تظهر أي تغذية راجعة للطالب.
              </p>
            </div>
            <div className="flex flex-wrap justify-center gap-4 pt-4 border-t">
              <button
                onClick={handleSave}
                className="flex items-center gap-2 bg-green-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-green-600 transition-colors shadow"
              >
                <Save /> حفظ التعديلات
              </button>
              <button
                onClick={() => {
                  handleSave();
                  onSaveAndNew();
                }}
                className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-blue-600 transition-colors shadow"
              >
                <PlusCircle /> حفظ وإضافة جديد
              </button>
              <button
                onClick={() => {
                  const savedQuestion = handleSave();
                  onPreview(savedQuestion);
                }}
                className="flex items-center gap-2 bg-gray-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-gray-600 transition-colors shadow"
              >
                معاينة
              </button>
            </div>
          </div>
        );
      };

      // ======== FROM: App.tsx ========
      const App = () => {
        const [questions, setQuestions] = React.useState([]);
        const [currentQuestionIndex, setCurrentQuestionIndex] =
          React.useState(0);
        const [draggedIndex, setDraggedIndex] = React.useState(null);
        const [filterType, setFilterType] = React.useState("all");
        const [searchTerm, setSearchTerm] = React.useState("");
        const [previewQuestion, setPreviewQuestion] = React.useState(null);
        const [isDocxReady, setIsDocxReady] = React.useState(false);
        const [isExportModalOpen, setIsExportModalOpen] = React.useState(false);

        const fileInputRef = React.useRef(null);

        React.useEffect(() => {
          const loadState = async () => {
            try {
              const state = await dbGet();
              if (
                state &&
                Array.isArray(state.questions) &&
                state.questions.length > 0
              ) {
                const sanitizedQuestions = state.questions.map((q) =>
                  ensureQuestionSanity(q)
                );
                setQuestions(sanitizedQuestions);
                const newIndex =
                  state.currentQuestionIndex >= sanitizedQuestions.length
                    ? 0
                    : state.currentQuestionIndex;
                setCurrentQuestionIndex(newIndex || 0);
                return;
              }
            } catch (error) {
              console.error("Failed to restore state:", error);
            }

            const initialQuestion = ensureQuestionSanity({
              type: "multiple-choice",
              options: [
                { text: "", image: null },
                { text: "", image: null },
              ],
              correct: 0,
            });
            setQuestions([initialQuestion]);
            setCurrentQuestionIndex(0);
          };

          loadState();
        }, []);

        React.useEffect(() => {
          if (questions.length === 0) return;

          const handler = setTimeout(async () => {
            try {
              const stateToSave = { questions, currentQuestionIndex };
              await dbSet(stateToSave);
            } catch (error) {
              console.error("Failed to save state to IndexedDB:", error);
              alert(
                "حدث خطأ غير متوقع أثناء حفظ الاختبار. يرجى التحقق من وحدة التحكم."
              );
            }
          }, 500);

          return () => {
            clearTimeout(handler);
          };
        }, [questions, currentQuestionIndex]);

        React.useEffect(() => {
          // The docx library is now loaded via a <script> tag in index.html.
          // This effect checks for its presence and sets the state.
          if (window.docx) {
            setIsDocxReady(true);
          } else {
            // Poll for the library if it loads asynchronously
            const interval = setInterval(() => {
              if (window.docx) {
                setIsDocxReady(true);
                clearInterval(interval);
              }
            }, 100);
            return () => clearInterval(interval);
          }
        }, []);

        const handleUpdateQuestion = (updatedQuestion) => {
          const newQuestions = [...questions];
          newQuestions[currentQuestionIndex] = updatedQuestion;
          setQuestions(newQuestions);
        };

        const handleAddNewQuestion = (index = -1) => {
          const newQuestion = ensureQuestionSanity({
            type: "multiple-choice",
            options: [
              { text: "", image: null },
              { text: "", image: null },
            ],
            correct: 0,
          });
          const newQuestions = [...questions];
          const insertionIndex = index === -1 ? questions.length : index;
          newQuestions.splice(insertionIndex, 0, newQuestion);
          setQuestions(newQuestions);
          setCurrentQuestionIndex(insertionIndex);
        };

        const handleSaveAndAddNew = () => {
          handleAddNewQuestion(currentQuestionIndex + 1);
        };

        const handleSelectQuestion = (index) => {
          setCurrentQuestionIndex(index);
        };

        const handleDeleteQuestion = (index) => {
          if (questions.length <= 1) {
            alert("لا يمكن حذف السؤال الوحيد!");
            return;
          }
          if (window.confirm(`هل أنت متأكد من حذف السؤال رقم ${index + 1}؟`)) {
            const newQuestions = questions.filter((_, i) => i !== index);
            setQuestions(newQuestions);
            if (currentQuestionIndex >= index) {
              setCurrentQuestionIndex(Math.max(0, currentQuestionIndex - 1));
            }
          }
        };

        const handleDuplicateQuestion = (index) => {
          const questionToDuplicate = JSON.parse(
            JSON.stringify(questions[index])
          );
          const newQuestions = [...questions];
          newQuestions.splice(index + 1, 0, questionToDuplicate);
          setQuestions(newQuestions);
          setCurrentQuestionIndex(index + 1);
        };

        const handleQuestionDragStart = (index) => {
          setDraggedIndex(index);
        };

        const handleQuestionDrop = (targetOriginalIndex) => {
          const sourceOriginalIndex = draggedIndex;
          if (
            sourceOriginalIndex === null ||
            sourceOriginalIndex === targetOriginalIndex
          ) {
            setDraggedIndex(null);
            return;
          }

          const newQuestions = moveItem(
            questions,
            sourceOriginalIndex,
            targetOriginalIndex
          );

          let newCurrentIndex = currentQuestionIndex;
          if (currentQuestionIndex === sourceOriginalIndex) {
            newCurrentIndex = targetOriginalIndex;
          } else if (
            sourceOriginalIndex < currentQuestionIndex &&
            targetOriginalIndex >= currentQuestionIndex
          ) {
            newCurrentIndex--;
          } else if (
            sourceOriginalIndex > currentQuestionIndex &&
            targetOriginalIndex <= currentQuestionIndex
          ) {
            newCurrentIndex++;
          }

          setQuestions(newQuestions);
          setCurrentQuestionIndex(newCurrentIndex);
          setDraggedIndex(null);
        };

        const handleImport = () => {
          fileInputRef.current?.click();
        };

        const handleFileChange = (event) => {
          const files = event.target.files;
          if (!files || files.length === 0) return;

          const readPromises = Array.from(files).map((file) => {
            return new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const data = JSON.parse(e.target.result);
                  if (!Array.isArray(data)) {
                    alert(`الملف ${file.name} بصيغة غير صحيحة، سيتم تجاهله.`);
                    resolve([]);
                    return;
                  }
                  resolve(data.map((q) => ensureQuestionSanity(q)));
                } catch (err) {
                  alert(`حدث خطأ أثناء تحليل الملف ${file.name}، سيتم تجاهله.`);
                  console.error(`Error parsing ${file.name}:`, err);
                  resolve([]);
                }
              };
              reader.onerror = () => {
                alert(`فشل قراءة الملف ${file.name}.`);
                resolve([]);
              };
              reader.readAsText(file);
            });
          });

          Promise.all(readPromises).then((results) => {
            const allNewQuestions = results.flat();

            if (allNewQuestions.length > 0) {
              setQuestions((prevQuestions) => {
                const isPlaceholder =
                  prevQuestions.length === 1 &&
                  !stripHtml(prevQuestions[0].question.text) &&
                  !prevQuestions[0].question.image &&
                  (prevQuestions[0].type !== "multiple-choice" ||
                    (prevQuestions[0].options || []).every(
                      (o) => !o.text && !o.image
                    ));

                const finalQuestions = isPlaceholder
                  ? allNewQuestions
                  : [...prevQuestions, ...allNewQuestions];

                if (isPlaceholder) {
                  setCurrentQuestionIndex(0);
                }

                alert(
                  `تم استيراد ${allNewQuestions.length} سؤال بنجاح. العدد الإجمالي الآن هو ${finalQuestions.length} سؤال.`
                );
                return finalQuestions;
              });
            } else {
              alert("لم يتم العثور على أسئلة صالحة في الملفات المحددة.");
            }

            if (event.target) event.target.value = "";
          });
        };

        const handleExportJson = () => {
          if (questions.length === 0) {
            alert("لا توجد أسئلة لتصديرها!");
            return;
          }
          const dataStr = JSON.stringify(questions, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "quiz_questions.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const handleOpenExportModal = () => {
          if (questions.length === 0) {
            alert("لا توجد أسئلة لتصديرها!");
            return;
          }
          setIsExportModalOpen(true);
        };

        const executeWordExport = async (options) => {
          setIsExportModalOpen(false);
          try {
            await exportQuestionsToWord(questions, options);
          } catch (error) {
            console.error("Failed to export to Word:", error);
            alert("حدث خطأ أثناء تصدير ملف Word.");
          }
        };

        const handleReset = async () => {
          if (
            window.confirm("سيتم مسح جميع الأسئلة الحالية. هل تريد المتابعة؟")
          ) {
            try {
              await dbClear();
              const initialQuestion = ensureQuestionSanity({
                type: "multiple-choice",
                options: [
                  { text: "", image: null },
                  { text: "", image: null },
                ],
                correct: 0,
              });
              setQuestions([initialQuestion]);
              setCurrentQuestionIndex(0);
            } catch (error) {
              console.error("Failed to reset state:", error);
              alert("فشل مسح الأسئلة.");
            }
          }
        };

        const currentQuestion = questions[currentQuestionIndex] || null;

        const displayedQuestions = React.useMemo(() => {
          return questions
            .map((q, index) => ({ ...q, originalIndex: index }))
            .filter((item) => {
              const typeMatch =
                filterType === "all" || item.type === filterType;
              const searchMatch =
                !searchTerm ||
                stripHtml(item.question.text)
                  .toLowerCase()
                  .includes(searchTerm.toLowerCase());
              return typeMatch && searchMatch;
            });
        }, [questions, filterType, searchTerm]);

        return (
          <div className="min-h-screen text-gray-800 p-4 lg:p-6">
            <div className="container mx-auto max-w-7xl">
              <header className="text-center p-6 bg-white rounded-xl shadow-md mb-6">
                <h1 className="text-3xl lg:text-4xl font-bold text-blue-600">
                  محرر الأسئلة المطور
                </h1>
                <p className="text-gray-600 mt-2">
                  أنشئ وحرر أسئلة اختبارك ثم قم بتصديرها للاستخدام في الاختبار
                  التفاعلي.
                </p>
              </header>

              <div className="flex flex-wrap justify-center gap-3 p-4 bg-white rounded-xl shadow-md mb-6">
                <button
                  onClick={handleImport}
                  className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow"
                >
                  <UploadIcon /> استيراد (JSON)
                </button>
                <button
                  onClick={handleExportJson}
                  className="flex items-center gap-2 bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600 transition-colors shadow"
                >
                  <DownloadIcon /> تصدير (JSON)
                </button>
                <button
                  onClick={handleOpenExportModal}
                  className="flex items-center gap-2 bg-sky-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-sky-600 transition-colors shadow disabled:bg-sky-300 disabled:cursor-not-allowed"
                  disabled={!isDocxReady}
                  title={
                    !isDocxReady
                      ? "مكتبة التصدير قيد التحميل..."
                      : "تصدير الأسئلة إلى مستند Word"
                  }
                >
                  <FileTextIcon />
                  {isDocxReady ? "تصدير إلى Word" : "جاري التحميل..."}
                </button>
                <button
                  onClick={() => handleAddNewQuestion(-1)}
                  className="flex items-center gap-2 bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors shadow"
                >
                  <PlusIcon /> إضافة سؤال جديد
                </button>
                <button
                  onClick={handleReset}
                  className="flex items-center gap-2 bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors shadow"
                >
                  <TrashIcon /> مسح كل الأسئلة
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileChange}
                  accept=".json,application/json"
                  className="hidden"
                  multiple
                />
              </div>

              <main className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2">
                  {currentQuestion && (
                    <EditorPanel
                      key={currentQuestionIndex}
                      question={currentQuestion}
                      onUpdate={handleUpdateQuestion}
                      questionNumber={currentQuestionIndex + 1}
                      onSaveAndNew={handleSaveAndAddNew}
                      onPreview={setPreviewQuestion}
                    />
                  )}
                  {previewQuestion && (
                    <PreviewModal
                      question={previewQuestion}
                      onClose={() => setPreviewQuestion(null)}
                    />
                  )}
                </div>
                <div className="lg:col-span-1">
                  {questions.length > 0 && (
                    <QuestionList
                      questions={displayedQuestions}
                      currentQuestionIndex={currentQuestionIndex}
                      onSelectQuestion={handleSelectQuestion}
                      onDeleteQuestion={handleDeleteQuestion}
                      onDuplicateQuestion={handleDuplicateQuestion}
                      onAddNewQuestion={handleAddNewQuestion}
                      onDragStart={handleQuestionDragStart}
                      onDrop={handleQuestionDrop}
                      filterType={filterType}
                      onFilterChange={setFilterType}
                      searchTerm={searchTerm}
                      onSearchChange={setSearchTerm}
                    />
                  )}
                </div>
              </main>

              {isExportModalOpen && (
                <ExportOptionsModal
                  isOpen={isExportModalOpen}
                  onClose={() => setIsExportModalOpen(false)}
                  onConfirm={executeWordExport}
                />
              )}

              <footer className="mt-8 text-center p-4 bg-white rounded-lg shadow-sm">
                <a
                  href="https://t.me/Interact2030"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-gray-600 hover:text-blue-600 transition-colors text-sm"
                >
                  برمجة و تصميم/ ملتقى التعليم التفاعلي بملتقى معلمي ومعلمات
                  الرياضيات ـ المملكة العربية السعودية
                </a>
              </footer>
            </div>
          </div>
        );
      };

      // ======== FROM: index.tsx (Render Logic) ========
      const rootElement = document.getElementById("root");
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
