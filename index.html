<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>محرر الأسئلة المطور</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="css/styles.css" />
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>
    <script type="text/babel">
      // All application source files are bundled here to work with Babel Standalone.
      // This allows the app to run from file:/// protocol without CORS or module resolution errors.
      // All TypeScript syntax has been removed.

      // ======== FROM: services/db.js ========
      const DB_NAME = "QuizEditorDB";
      const DB_VERSION = 5;
      const STORE_NAME = "state";
      const KEY = "appState";

      let dbPromise = null;

      const getDb = () => {
        if (dbPromise) {
          return dbPromise;
        }
        dbPromise = new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);
          request.onerror = () => {
            console.error("IndexedDB error:", request.error);
            reject("IndexedDB error");
          };
          request.onsuccess = () => {
            resolve(request.result);
          };
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              db.createObjectStore(STORE_NAME);
            }
          };
        });
        return dbPromise;
      };

      const dbGet = async () => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get(KEY);
          request.onsuccess = () => {
            resolve(request.result);
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      const dbSet = async (value) => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(value, KEY);
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      const dbClear = async () => {
        const db = await getDb();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(KEY);
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      };

      const moveItem = (array, fromIndex, toIndex) => {
        if (
          fromIndex < 0 ||
          fromIndex >= array.length ||
          toIndex < 0 ||
          toIndex >= array.length
        ) {
          return array;
        }
        const newArray = [...array];
        const [movedItem] = newArray.splice(fromIndex, 1);
        newArray.splice(toIndex, 0, movedItem);
        return newArray;
      };
      // ======== FROM: utils/quizUtils.js ========
      const stripHtml = (html) => {
        if (!html) return "";
        const doc = new DOMParser().parseFromString(html, "text/html");
        return doc.body.textContent || "";
      };

      const ensureQuestionSanity = (q) => {
        const baseQuestion = {
          type: q.type || "multiple-choice",
          reading: q.reading || { text: "", image: null, audio: null },
          question: q.question || { text: "", image: null },
          feedback: q.feedback || "",
        };

        switch (baseQuestion.type) {
          case "multiple-choice": {
            const options = q.options || [];
            return {
              ...baseQuestion,
              type: "multiple-choice",
              options: options,
              correct: q.correct || 0,
            };
          }
          case "fill-in-the-blank":
            return {
              ...baseQuestion,
              type: "fill-in-the-blank",
              correctAnswer: q.correctAnswer || "",
            };
          case "true-false":
            return {
              ...baseQuestion,
              type: "true-false",
              correctAnswer: q.correctAnswer === false ? false : true,
            };
          case "short-answer":
            return {
              ...baseQuestion,
              type: "short-answer",
              correctAnswer: q.correctAnswer || "",
            };
          case "connecting-lines":
          case "matching": {
            // On import, standardize on a single `pairs` array for local state
            const prompts = Array.isArray(q.prompts) ? q.prompts : [];
            const answers = Array.isArray(q.answers) ? q.answers : [];
            let pairs = Array.isArray(q.pairs) ? q.pairs : [];

            // Handle format from viewer.html (prompts/answers)
            if (prompts.length > 0 && pairs.length === 0) {
              pairs = prompts.map((p, i) => ({
                prompt: p || { text: "", image: null },
                answer: answers[i] || { text: "", image: null },
              }));
            }

            return {
              ...baseQuestion,
              type: baseQuestion.type,
              pairs: pairs,
            };
          }

          case "ordering": {
            // On import, trust the items. Don't pad.
            const items = Array.isArray(q.items) ? q.items : [];
            const sanitizedItems = items.map((item) =>
              typeof item === "string"
                ? { text: item, image: null }
                : item || { text: "", image: null }
            );
            return {
              ...baseQuestion,
              type: "ordering",
              items: sanitizedItems,
            };
          }
          default:
            return ensureQuestionSanity({ type: "multiple-choice" });
        }
      };

      // ======== FROM: components/Icons.jsx ========
      const UploadIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      );
      const DownloadIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </svg>
      );
      const PlusIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <line x1="12" y1="5" x2="12" y2="19" />
          <line x1="5" y1="12" x2="19" y2="12" />
        </svg>
      );
      const TrashIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <polyline points="3 6 5 6 21 6" />
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
        </svg>
      );
      const Edit = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
        </svg>
      );
      const Copy = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
          <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
        </svg>
      );
      const Plus = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M5 12h14" />
          <path d="M12 5v14" />
        </svg>
      );
      const Trash2 = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M3 6h18" />
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
          <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
          <line x1="10" x2="10" y1="11" y2="17" />
          <line x1="14" x2="14" y1="11" y2="17" />
        </svg>
      );
      const GripVertical = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <circle cx="9" cy="12" r="1" />
          <circle cx="9" cy="5" r="1" />
          <circle cx="9" cy="19" r="1" />
          <circle cx="15" cy="12" r="1" />
          <circle cx="15" cy="5" r="1" />
          <circle cx="15" cy="19" r="1" />
        </svg>
      );
      const ImageUp = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L13 16" />
          <path d="m17 22 5-5" />
          <path d="M22 22h-5v-5" />
          <circle cx="9" cy="9" r="2" />
        </svg>
      );
      const ClipboardPaste = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M15 2H9a2 2 0 0 0-2 2v2H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-2V4a2 2 0 0 0-2-2Z" />
          <path d="M9 2v4h6V2" />
          <path d="M12 12v6" />
          <path d="m15 15-3 3-3-3" />
        </svg>
      );
      const AudioLines = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M2 10v3" />
          <path d="M6 6v11" />
          <path d="M10 3v18" />
          <path d="M14 8v7" />
          <path d="M18 5v13" />
          <path d="M22 10v3" />
        </svg>
      );
      const Save = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
          <polyline points="17 21 17 13 7 13 7 21" />
          <polyline points="7 3 7 8 15 8" />
        </svg>
      );
      const PlusCircle = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <circle cx="12" cy="12" r="10" />
          <path d="M8 12h8" />
          <path d="M12 8v8" />
        </svg>
      );
      const RemoveFormattingIcon = ({ size = 20, className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className={className}
        >
          <path d="M4 7V4h16v3" />
          <path d="M5 20h14" />
          <path d="M12 4v16" />
          <path d="m16 12-3.515 3.515a2.12 2.12 0 0 1-3.02 0L8 14" />
          <path d="m18 9-1.5-1.5" />
          <path d="m6 9 1.5-1.5" />
          <path d="m15 6-1-1" />
          <path d="m9 6 1-1" />
          <path d="m12 20 1-1" />
          <path d="m12 20-1-1" />
        </svg>
      );

      // ======== FROM: components/RichTextEditor.jsx ========
      const RichTextEditor = ({ value, onChange, placeholder, height }) => {
        const editorRef = React.useRef(null);

        // This effect ensures the editor's content is updated only when the `value` prop changes from outside.
        // It prevents React from re-rendering and resetting the cursor/direction on every input.
        React.useEffect(() => {
          if (editorRef.current && value !== editorRef.current.innerHTML) {
            editorRef.current.innerHTML = value || "";
          }
        }, [value]);

        const handleInput = (e) => {
          onChange(e.target.innerHTML);
        };

        const handleCommand = (command, value = null) => {
          document.execCommand(command, false, value);
          // After executing a command, we might need to re-focus to ensure the next command works
          if (editorRef.current) {
            editorRef.current.focus();
          }
          onChange(editorRef.current.innerHTML); // Immediately reflect changes
        };

        return (
          <div className="border rounded-md bg-white">
            <div className="flex items-center gap-2 p-2 bg-gray-100 border-b rounded-t-md">
              <button
                type="button"
                onClick={() => handleCommand("bold")}
                className="w-8 h-8 font-bold hover:bg-gray-200 rounded"
              >
                B
              </button>
              <button
                type="button"
                onClick={() => handleCommand("italic")}
                className="w-8 h-8 italic font-serif hover:bg-gray-200 rounded"
              >
                I
              </button>
              <button
                type="button"
                onClick={() => handleCommand("underline")}
                className="w-8 h-8 underline hover:bg-gray-200 rounded"
              >
                U
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyRight")}
                className="w-8 h-8 hover:bg-gray-200 rounded"
                title="محاذاة لليمين"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="21" y1="10" x2="7" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="21" y1="14" x2="3" y2="14"></line>
                  <line x1="21" y1="18" x2="7" y2="18"></line>
                </svg>
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyCenter")}
                className="w-8 h-8 hover:bg-gray-200 rounded"
                title="توسيط"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="18" y1="10" x2="6" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="21" y1="14" x2="3" y2="14"></line>
                  <line x1="18" y1="18" x2="6" y2="18"></line>
                </svg>
              </button>
              <button
                type="button"
                onClick={() => handleCommand("justifyLeft")}
                className="w-8 h-8 hover:bg-gray-200 rounded"
                title="محاذاة لليسار"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <line x1="17" y1="10" x2="3" y2="10"></line>
                  <line x1="21" y1="6" x2="3" y2="6"></line>
                  <line x1="17" y1="14" x2="3" y2="14"></line>
                  <line x1="21" y1="18" x2="3" y2="18"></line>
                </svg>
              </button>
              <input
                type="color"
                onChange={(e) => handleCommand("foreColor", e.target.value)}
                className="w-8 h-8 p-1 border-none bg-transparent cursor-pointer"
                title="لون الخط"
              />
              <select
                onChange={(e) => {
                  if (e.target.value) {
                    editorRef.current?.focus(); // Re-focus the editor before executing the command
                    document.execCommand("fontSize", false, e.target.value);
                  }
                }}
                className="p-1 border rounded-md text-sm bg-white cursor-pointer h-8"
                title="حجم الخط"
              >
                <option value="">حجم الخط</option>
                <option value="1">صغير جداً</option>
                <option value="2">صغير</option>
                <option value="3">عادي</option>
                <option value="4">متوسط</option>
                <option value="5">كبير</option>
                <option value="6">كبير جداً</option>
                <option value="7">ضخم</option>
              </select>
              <select
                onChange={(e) => {
                  if (e.target.value) {
                    handleCommand("insertText", e.target.value);
                    e.target.value = ""; // Reset select
                  }
                }}
                className="p-1 border rounded-md text-sm bg-white cursor-pointer h-8"
                title="إدراج رمز"
              >
                <option value="">إدراج رمز</option>
                <option value=">">&gt;</option>
                <option value="<">&lt;</option>
                <option value="≥">≥</option>
                <option value="≤">≤</option>
                <option value="≠">≠</option>
                <option value="≈">≈</option>
                <option value="°">°</option>
                <option value="◯">◯</option>
                <option value="±">±</option>
                <option value="√">√</option>
              </select>
            </div>
            <button
              type="button"
              onClick={() => handleCommand("removeFormat")}
              className="w-8 h-8 hover:bg-gray-200 rounded flex justify-center items-center"
              title="مسح التنسيق"
            >
              <RemoveFormattingIcon size={18} />
            </button>
            <div
              ref={editorRef}
              contentEditable
              onInput={handleInput}
              className="w-full p-3 outline-none rte-content"
              style={{
                minHeight: height || "112px",
              }}
              placeholder={placeholder}
            ></div>
          </div>
        );
      };

      // ======== FROM: components/QuestionList.jsx ========
      const QuestionList = ({
        questions,
        currentQuestionIndex,
        onSelectQuestion,
        onDeleteQuestion,
        onDuplicateQuestion,
        onAddNewQuestion,
        onDragStart,
        onDrop, // New props for filtering and searching
        filterType,
        onFilterChange,
        searchTerm,
        onSearchChange,
      }) => {
        const [dragOverIndex, setDragOverIndex] = React.useState(null);
        const questionTypeMap = {
          "multiple-choice": "اختيار من متعدد",
          "fill-in-the-blank": "املأ الفراغ",
          "true-false": "صح/خطأ",
          "short-answer": "إجابة قصيرة",
          matching: "مطابقة",
          ordering: "ترتيب",
          "connecting-lines": "توصيل",
        };

        const handleDragOver = (e, index) => {
          e.preventDefault();
          setDragOverIndex(index);
        };

        return (
          <div className="bg-white p-4 rounded-xl shadow-md sticky top-6">
            <div className="text-center border-b pb-3 mb-3">
              <h3 className="text-xl font-bold text-gray-800">
                قائمة الأسئلة ({questions.length})
              </h3>
              <p className="text-sm text-gray-500">اسحب وأفلت لإعادة الترتيب</p>
            </div>
            <div className="p-2 space-y-3">
              <input
                type="text"
                placeholder="ابحث في نص السؤال..."
                value={searchTerm}
                onChange={(e) => onSearchChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white text-sm"
              />
              <select
                value={filterType}
                onChange={(e) => onFilterChange(e.target.value)}
                className="w-full p-2 border rounded-md bg-white text-sm"
              >
                <option value="all">كل أنواع الأسئلة</option>
                {Object.entries(questionTypeMap).map(([key, value]) => (
                  <option key={key} value={key}>
                    {value}
                  </option>
                ))}
              </select>
            </div>
            <ul className="space-y-2 max-h-[75vh] overflow-y-auto pr-2">
              {questions.map((q, index) => {
                // Use originalIndex for actions, but the list's own index for display logic
                const originalIndex = q.originalIndex;
                const isActive = originalIndex === currentQuestionIndex;
                const previewText =
                  stripHtml(q.question.text || "سؤال فارغ").substring(0, 50) +
                  "...";
                return (
                  <li
                    key={originalIndex} // Use originalIndex for a stable key
                    draggable
                    onDragStart={() => onDragStart(originalIndex)}
                    onDragOver={(e) => handleDragOver(e, index)}
                    onDragLeave={() => setDragOverIndex(null)}
                    onDrop={() => onDrop(originalIndex)}
                    className={`p-3 rounded-lg border-2 transition-all duration-200 cursor-pointer group ${
                      isActive
                        ? "bg-blue-100 border-blue-500 shadow-md"
                        : "bg-gray-50 border-gray-200 hover:border-blue-300 hover:bg-blue-50"
                    } ${
                      dragOverIndex === index
                        ? "transform scale-105 bg-blue-200"
                        : ""
                    }`}
                  >
                    <div className="flex items-start gap-2">
                      <div className="flex-shrink-0 cursor-grab text-gray-400 group-hover:text-gray-600 pt-1">
                        <GripVertical />
                      </div>
                      <div
                        className="flex-grow"
                        onClick={() => onSelectQuestion(originalIndex)}
                      >
                        <div className="flex justify-between items-center">
                          <span className="font-bold text-gray-800">
                            السؤال {originalIndex + 1}
                          </span>
                          <span className="text-xs bg-gray-200 text-gray-600 px-2 py-0.5 rounded-full">
                            {questionTypeMap[q.type]}
                          </span>
                        </div>
                        <p className="text-sm text-gray-600 mt-1">
                          {previewText}
                        </p>
                      </div>
                    </div>
                    <div className="flex justify-end gap-2 mt-2 pt-2 border-t border-gray-200">
                      <button
                        title="تعديل"
                        onClick={() => onSelectQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-blue-600 rounded-full hover:bg-blue-100"
                      >
                        <Edit size={16} />
                      </button>
                      <button
                        title="نسخ"
                        onClick={() => onDuplicateQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-green-600 rounded-full hover:bg-green-100"
                      >
                        <Copy size={16} />
                      </button>
                      <button
                        title="إدراج سؤال"
                        onClick={() => onAddNewQuestion(originalIndex + 1)}
                        className="p-1.5 text-gray-500 hover:text-indigo-600 rounded-full hover:bg-indigo-100"
                      >
                        <Plus size={16} />
                      </button>
                      <button
                        title="حذف"
                        onClick={() => onDeleteQuestion(originalIndex)}
                        className="p-1.5 text-gray-500 hover:text-red-600 rounded-full hover:bg-red-100"
                      >
                        <Trash2 size={16} />
                      </button>
                    </div>
                  </li>
                );
              })}
            </ul>
          </div>
        );
      };

      // ======== FROM: components/EditorPanel.jsx ========
      const MediaInput = ({
        label,
        image,
        onImageChange,
        audio,
        onAudioChange,
      }) => {
        const imageInputRef = React.useRef(null);
        const audioInputRef = React.useRef(null);

        const handleFileChange = (e, setter) => {
          const file = e.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => setter(event.target?.result);
            reader.readAsDataURL(file);
          }
          e.target.value = "";
        };

        const handlePaste = async (setter) => {
          try {
            const items = await navigator.clipboard.read();
            const imageItem = items.find((item) =>
              item.types.some((t) => t.startsWith("image/"))
            );
            if (imageItem) {
              const type = imageItem.types.find((t) => t.startsWith("image/"));
              const blob = await imageItem.getType(type);
              const reader = new FileReader();
              reader.onload = (e) => setter(e.target?.result);
              reader.readAsDataURL(blob);
            } else {
              alert("لا توجد صورة في الحافظة.");
            }
          } catch (err) {
            console.error("Paste error:", err);
            alert(
              "فشل لصق الصورة. قد تحتاج إلى منح الإذن بالوصول إلى الحافظة."
            );
          }
        };

        return (
          <div className="space-y-4">
            <h3 className="font-semibold text-gray-700">{label}</h3>
            <div className="flex items-center gap-2">
              <button
                onClick={() => imageInputRef.current?.click()}
                className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
              >
                <ImageUp size={16} /> صورة
              </button>
              <input
                type="file"
                ref={imageInputRef}
                onChange={(e) => handleFileChange(e, onImageChange)}
                accept="image/*"
                className="hidden"
              />
              <button
                onClick={() => handlePaste(onImageChange)}
                className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
              >
                <ClipboardPaste size={16} /> لصق
              </button>
              {image && (
                <button
                  onClick={() => onImageChange(null)}
                  className="flex items-center gap-2 text-sm bg-red-100 text-red-600 hover:bg-red-200 px-3 py-1.5 rounded-md transition-colors"
                >
                  <Trash2 size={16} /> حذف
                </button>
              )}
            </div>
            {image && (
              <img
                src={image}
                alt="معاينة"
                className="mt-2 rounded-lg border-2 border-dashed border-gray-300 p-1 max-h-40 object-contain"
              />
            )}

            {onAudioChange && (
              <>
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => audioInputRef.current?.click()}
                    className="flex items-center gap-2 text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1.5 rounded-md transition-colors"
                  >
                    <AudioLines size={16} /> صوت
                  </button>
                  <input
                    type="file"
                    ref={audioInputRef}
                    onChange={(e) => handleFileChange(e, onAudioChange)}
                    accept="audio/*"
                    className="hidden"
                  />
                  {audio && (
                    <button
                      onClick={() => onAudioChange(null)}
                      className="flex items-center gap-2 text-sm bg-red-100 text-red-600 hover:bg-red-200 px-3 py-1.5 rounded-md transition-colors"
                    >
                      <Trash2 size={16} /> حذف
                    </button>
                  )}
                </div>
                {audio && (
                  <audio src={audio} controls className="mt-2 w-full" />
                )}
              </>
            )}
          </div>
        );
      };

      const EditorPanel = ({
        question,
        onUpdate,
        questionNumber,
        onSaveAndNew,
      }) => {
        const [localQuestion, setLocalQuestion] = React.useState(question);
        const [draggedItem, setDraggedItem] = React.useState({
          type: null,
          index: -1,
        });

        React.useEffect(() => {
          setLocalQuestion(question);
        }, [question]);

        const handleChange = (key, value) => {
          setLocalQuestion((prev) => ({ ...prev, [key]: value }));
        };

        const handleNestedChange = (part, key, value) => {
          setLocalQuestion((prev) => ({
            ...prev,
            [part]: { ...prev[part], [key]: value },
          }));
        };

        const handleSave = () => {
          // Clean trailing spaces and &nbsp; before updating
          const cleanHtml = (html) =>
            (html || "").replace(/(<p><br><\/p>|\s|&nbsp;)*$/, "").trim();

          // Before saving, convert `pairs` back to `prompts` and `answers` for compatibility
          if (
            localQuestion.type === "matching" ||
            localQuestion.type === "connecting-lines"
          ) {
            const pairs = localQuestion.pairs || [];
            localQuestion.prompts = pairs.map(
              (p) => p.prompt || { text: "", image: null }
            );
            localQuestion.answers = pairs.map(
              (p) => p.answer || { text: "", image: null }
            );
            delete localQuestion.pairs; // Clean up the temporary property
          }

          localQuestion.reading.text = cleanHtml(localQuestion.reading.text);
          localQuestion.question.text = cleanHtml(localQuestion.question.text);
          localQuestion.feedback = cleanHtml(localQuestion.feedback);

          onUpdate(localQuestion);
        };

        const handleTypeChange = (e) => {
          const newType = e.target.value;
          const newQuestionState = ensureQuestionSanity({
            type: newType,
            reading: localQuestion.reading,
            question: localQuestion.question,
          });
          onUpdate(newQuestionState);
        };

        const handleOptionChange = (index, key, value) => {
          const newOptions = [...localQuestion.options];
          newOptions[index][key] = value;
          handleChange("options", newOptions);
        };

        const handleCorrectChange = (newCorrectIndex) => {
          handleChange("correct", newCorrectIndex);
        };

        const handlePairChange = (index, part, key, value) => {
          const newPairs = [...localQuestion.pairs];
          newPairs[index] = {
            ...newPairs[index],
            [part]: {
              ...(newPairs[index]?.[part] || {}),
              [key]: value,
            },
          };
          handleChange("pairs", newPairs);
        };

        const handleRemovePair = (index) => {
          const newPairs = localQuestion.pairs.filter((_, i) => i !== index);
          handleChange("pairs", newPairs);
        };

        const handleAddOption = () => {
          const newOptions = [
            ...localQuestion.options,
            { text: "", image: null },
          ];
          handleChange("options", newOptions);
        };

        const handleDragStart = (type, index) => {
          setDraggedItem({ type, index });
        };

        const handleDrop = (type, targetIndex) => {
          if (
            draggedItem.type !== type ||
            draggedItem.index === -1 ||
            draggedItem.index === targetIndex
          ) {
            return;
          }

          let currentArray = localQuestion[type];
          let correctIndex = localQuestion.correct;

          // Adjust correct index for multiple-choice options
          if (type === "options") {
            const draggedOptionIsCorrect = draggedItem.index === correctIndex;
            const targetOptionIsCorrect = targetIndex === correctIndex;

            if (draggedOptionIsCorrect) {
              correctIndex = targetIndex;
            } else if (!targetOptionIsCorrect) {
              if (
                draggedItem.index < correctIndex &&
                targetIndex >= correctIndex
              ) {
                correctIndex--;
              } else if (
                draggedItem.index > correctIndex &&
                targetIndex <= correctIndex
              ) {
                correctIndex++;
              }
            }
          }

          const newArray = moveItem(
            currentArray,
            draggedItem.index,
            targetIndex
          );

          setLocalQuestion((prev) => ({
            ...prev,
            [type]: newArray,
            ...(type === "options" && { correct: correctIndex }),
          }));

          setDraggedItem({ type: null, index: -1 });
        };

        const renderEditorFields = () => {
          switch (localQuestion.type) {
            case "multiple-choice":
              return (
                <div className="space-y-4">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      الخيارات (يجب تحديد الإجابة الصحيحة)
                    </label>
                    <button
                      onClick={handleAddOption}
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة خيار
                    </button>
                  </div>
                  {localQuestion.options?.map((opt, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("options", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("options", index)}
                      className="p-3 bg-white rounded-lg border relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2 flex items-center gap-1">
                        {localQuestion.options.length > 2 && (
                          <button
                            onClick={() => {
                              let newCorrect = localQuestion.correct;
                              if (index === localQuestion.correct) {
                                newCorrect = 0;
                              } else if (index < localQuestion.correct) {
                                newCorrect--;
                              }
                              const newOptions = localQuestion.options.filter(
                                (_, i) => i !== index
                              );
                              setLocalQuestion((prev) => ({
                                ...prev,
                                options: newOptions,
                                correct: newCorrect,
                              }));
                            }}
                            className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                            title="حذف الخيار"
                          >
                            <Trash2 size={16} />
                          </button>
                        )}
                      </div>
                      <div className="flex items-start gap-3 mb-2 pr-8 pl-8">
                        <input
                          type="radio"
                          name="correctOption"
                          checked={localQuestion.correct === index}
                          onChange={() => handleCorrectChange(index)}
                          className="form-radio h-5 w-5 text-blue-600 mt-2.5 flex-shrink-0"
                        />
                        <div className="flex-grow space-y-2">
                          <input
                            type="text"
                            placeholder={`الخيار ${index + 1}`}
                            value={opt.text}
                            onChange={(e) =>
                              handleOptionChange(index, "text", e.target.value)
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={opt.image}
                            onImageChange={(img) =>
                              handleOptionChange(index, "image", img)
                            }
                          />
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              );
            case "fill-in-the-blank":
              return (
                <div>
                  <label
                    htmlFor="correctAnswer"
                    className="font-semibold text-lg text-gray-800"
                  >
                    الإجابة الصحيحة:
                  </label>
                  <input
                    id="correctAnswer"
                    type="text"
                    value={localQuestion.correctAnswer}
                    onChange={(e) =>
                      handleChange("correctAnswer", e.target.value)
                    }
                    className="w-full mt-2 p-2 border rounded-md"
                    placeholder="اكتب الإجابة هنا..."
                  />
                  <p className="text-sm text-gray-500 mt-2">
                    ملاحظة: يمكنك وضع عدة إجابات صحيحة بفصلها بعلامة | (مثال:
                    إجابة1|إجابة2)
                  </p>
                </div>
              );
            case "true-false":
              return (
                <div className="space-y-2">
                  <label className="font-semibold text-lg text-gray-800">
                    الإجابة الصحيحة:
                  </label>
                  <div className="flex gap-4">
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="radio"
                        name="tf-answer"
                        checked={localQuestion.correctAnswer === true}
                        onChange={() => handleChange("correctAnswer", true)}
                        className="form-radio h-5 w-5 text-blue-600"
                      />
                      صح
                    </label>
                    <label className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="radio"
                        name="tf-answer"
                        checked={localQuestion.correctAnswer === false}
                        onChange={() => handleChange("correctAnswer", false)}
                        className="form-radio h-5 w-5 text-blue-600"
                      />
                      خطأ
                    </label>
                  </div>
                </div>
              );
            case "short-answer":
              return (
                <div>
                  <label
                    htmlFor="shortAnswer"
                    className="font-semibold text-lg text-gray-800"
                  >
                    الإجابات الصحيحة المحتملة:
                  </label>
                  <textarea
                    id="shortAnswer"
                    value={localQuestion.correctAnswer}
                    onChange={(e) =>
                      handleChange("correctAnswer", e.target.value)
                    }
                    className="w-full mt-2 p-2 border rounded-md h-24"
                    placeholder="اكتب الإجابات هنا..."
                  />
                  <p className="text-sm text-gray-500 mt-2">
                    اكتب الإجابات الصحيحة المحتملة. افصل بين كل إجابة بعلامة | .
                    سيتم التحقق من تطابق إجابة الطالب مع أي من هذه الإجابات.
                  </p>
                </div>
              );

            case "connecting-lines":
            case "matching": {
              const title =
                localQuestion.type === "matching"
                  ? "أزواج المطابقة"
                  : "أزواج التوصيل";
              return (
                <div className="space-y-5">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      {title}
                    </label>
                    <button
                      onClick={() => {
                        const newPairs = [
                          ...(localQuestion.pairs || []),
                          {
                            prompt: { text: "", image: null },
                            answer: { text: "", image: null },
                          },
                        ];
                        handleChange("pairs", newPairs);
                      }}
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة زوج
                    </button>
                  </div>
                  {(localQuestion.pairs || []).map((pair, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("pairs", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("pairs", index)}
                      className="p-3 bg-white rounded-lg border relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 pt-6">
                        <div className="space-y-2">
                          <label className="text-sm font-medium text-gray-600">
                            العنصر {index + 1}
                          </label>
                          <input
                            type="text"
                            placeholder={`العنصر ${index + 1}`}
                            value={pair.prompt?.text || ""}
                            onChange={(e) =>
                              handlePairChange(
                                index,
                                "prompt",
                                "text",
                                e.target.value
                              )
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={pair.prompt?.image}
                            onImageChange={(img) =>
                              handlePairChange(index, "prompt", "image", img)
                            }
                          />
                        </div>
                        <div className="space-y-2">
                          <label className="text-sm font-medium text-gray-600">
                            الإجابة {index + 1}
                          </label>
                          <input
                            type="text"
                            placeholder={`الإجابة ${index + 1}`}
                            value={pair.answer?.text || ""}
                            onChange={(e) =>
                              handlePairChange(
                                index,
                                "answer",
                                "text",
                                e.target.value
                              )
                            }
                            className="w-full p-2 border rounded-md"
                          />
                          <MediaInput
                            label=""
                            image={pair.answer?.image}
                            onImageChange={(img) =>
                              handlePairChange(index, "answer", "image", img)
                            }
                          />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2">
                        <button
                          onClick={() => handleRemovePair(index)}
                          className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                          title="حذف الزوج"
                        >
                          <Trash2 size={16} />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              );
            }

            case "ordering":
              return (
                <div className="space-y-5">
                  <div className="flex justify-between items-center">
                    <label className="font-semibold text-lg text-gray-800">
                      عناصر الترتيب (بالترتيب الصحيح):
                    </label>
                    <button
                      onClick={() => {
                        const newItems = [
                          ...localQuestion.items,
                          { text: "", image: null },
                        ];
                        handleChange("items", newItems);
                      }}
                      className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-1.5 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm"
                    >
                      <PlusIcon size={16} /> إضافة عنصر
                    </button>
                  </div>
                  {localQuestion.items?.map((item, index) => (
                    <div
                      key={index}
                      draggable
                      onDragStart={() => handleDragStart("items", index)}
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => handleDrop("items", index)}
                      className="p-3 bg-white rounded-lg border space-y-2 relative transition-shadow hover:shadow-md"
                    >
                      <div className="absolute top-1/2 -translate-y-1/2 right-2 flex items-center gap-2">
                        <div className="cursor-grab text-gray-400">
                          <GripVertical size={18} />
                        </div>
                      </div>
                      <div className="absolute top-2 left-2">
                        <button
                          onClick={() => {
                            const newItems = localQuestion.items.filter(
                              (_, i) => i !== index
                            );
                            handleChange("items", newItems);
                          }}
                          className="p-1.5 text-red-500 hover:text-red-700 rounded-full hover:bg-red-100"
                          title="حذف العنصر"
                        >
                          <Trash2 size={16} />
                        </button>
                      </div>
                      <div className="pr-8">
                        <input
                          type="text"
                          placeholder={`العنصر ${index + 1} (نص)`}
                          value={item.text}
                          onChange={(e) => {
                            const newItems = [...localQuestion.items];
                            newItems[index] = {
                              ...newItems[index],
                              text: e.target.value,
                            };
                            handleChange("items", newItems);
                          }}
                          className="w-full p-2 border rounded-md"
                        />
                        <MediaInput
                          label=""
                          image={item.image}
                          onImageChange={(img) => {
                            const newItems = [...localQuestion.items];
                            newItems[index] = {
                              ...newItems[index],
                              image: img,
                            };
                            handleChange("items", newItems);
                          }}
                        />
                      </div>
                    </div>
                  ))}
                  <p className="text-sm text-gray-500 mt-2">
                    املأ العناصر التي تريدها بالترتيب الصحيح. يمكن أن يكون كل
                    عنصر نصًا أو صورة أو كليهما. سيتم تجاهل الحقول الفارغة. يجب
                    ملء عنصرين على الأقل.
                  </p>
                </div>
              );
            default:
              return null;
          }
        };

        return (
          <div className="bg-white p-6 rounded-xl shadow-md space-y-6">
            <h2 className="text-2xl font-bold text-blue-600 border-b pb-3">
              تحرير السؤال{" "}
              <span className="text-gray-500 font-medium">
                ({questionNumber})
              </span>
            </h2>

            <div className="p-4 bg-gray-50 rounded-lg border">
              <label
                htmlFor="questionType"
                className="font-semibold text-gray-700"
              >
                نوع السؤال:
              </label>
              <select
                id="questionType"
                value={localQuestion.type}
                onChange={handleTypeChange}
                className="w-full mt-2 p-2 border rounded-md bg-white"
              >
                <option value="multiple-choice">اختيار من متعدد</option>
                <option value="fill-in-the-blank">املأ الفراغ</option>
                <option value="true-false">صح / خطأ</option>
                <option value="short-answer">إجابة قصيرة</option>
                <option value="matching">مطابقة</option>
                <option value="ordering">ترتيب</option>
                <option value="connecting-lines">توصيل</option>
              </select>
            </div>

            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">
                النص القرائي (اختياري):
              </label>
              <RichTextEditor
                value={localQuestion.reading.text}
                onChange={(e) => handleNestedChange("reading", "text", e)}
                placeholder="اكتب النص القرائي هنا..."
              />
              <MediaInput
                label=""
                image={localQuestion.reading.image}
                onImageChange={(img) =>
                  handleNestedChange("reading", "image", img)
                }
                audio={localQuestion.reading.audio}
                onAudioChange={(aud) =>
                  handleNestedChange("reading", "audio", aud)
                }
              />
            </div>

            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">نص السؤال:</label>
              <RichTextEditor
                placeholder="اكتب السؤال هنا..."
                value={localQuestion.question.text}
                onChange={(e) => handleNestedChange("question", "text", e)}
                height="80px"
              />
              <MediaInput
                label=""
                image={localQuestion.question.image}
                onImageChange={(img) =>
                  handleNestedChange("question", "image", img)
                }
              />
            </div>

            <div className="p-4 bg-gray-50 rounded-lg border">
              {renderEditorFields()}
            </div>

            <div className="p-4 bg-gray-50 rounded-lg border space-y-3">
              <label className="font-semibold text-gray-700">
                التغذية الراجعة (اختياري):
              </label>
              <RichTextEditor
                placeholder="اكتب هنا شرحًا للإجابة الصحيحة أو سبب خطأ الإجابات الأخرى. ستظهر هذه الرسالة للطالب بعد الإجابة."
                value={localQuestion.feedback || ""}
                onChange={(e) => handleChange("feedback", e)}
                height="96px"
              />
              <p className="text-sm text-gray-500">
                إذا تركت هذا الحقل فارغًا، فلن تظهر أي تغذية راجعة للطالب.
              </p>
            </div>

            <div className="flex flex-wrap justify-center gap-4 pt-4 border-t">
              <button
                onClick={handleSave}
                className="flex items-center gap-2 bg-green-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-green-600 transition-colors shadow"
              >
                <Save /> حفظ التعديلات
              </button>
              <button
                onClick={() => {
                  handleSave();
                  onSaveAndNew();
                }}
                className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-2 px-5 rounded-lg hover:bg-blue-600 transition-colors shadow"
              >
                <PlusCircle /> حفظ وإضافة جديد
              </button>
            </div>
          </div>
        );
      };

      // ======== FROM: App.jsx ========
      const App = () => {
        const [questions, setQuestions] = React.useState([]);
        const [currentQuestionIndex, setCurrentQuestionIndex] =
          React.useState(0);
        const [draggedIndex, setDraggedIndex] = React.useState(null);
        const [filterType, setFilterType] = React.useState("all");
        const [searchTerm, setSearchTerm] = React.useState("");

        const fileInputRef = React.useRef(null);

        React.useEffect(() => {
          const loadState = async () => {
            const LS_STORAGE_KEY = "quiz_editor_react_v1";
            try {
              let state = await dbGet();

              if (!state) {
                const lsStateRaw = localStorage.getItem(LS_STORAGE_KEY);
                if (lsStateRaw) {
                  console.log(
                    "Migrating state from localStorage to IndexedDB..."
                  );
                  state = JSON.parse(lsStateRaw);
                  await dbSet(state);
                  localStorage.removeItem(LS_STORAGE_KEY);
                }
              }

              if (
                state &&
                Array.isArray(state.questions) &&
                state.questions.length > 0
              ) {
                const sanitizedQuestions = state.questions.map((q) =>
                  ensureQuestionSanity(q)
                );
                setQuestions(sanitizedQuestions);
                const newIndex =
                  state.currentQuestionIndex >= sanitizedQuestions.length
                    ? 0
                    : state.currentQuestionIndex;
                setCurrentQuestionIndex(newIndex || 0);
                return;
              }
            } catch (error) {
              console.error("Failed to restore state:", error);
            }

            const initialQuestion = ensureQuestionSanity({
              type: "multiple-choice",
            });
            setQuestions([initialQuestion]);
            setCurrentQuestionIndex(0);
          };

          loadState();
        }, []);

        React.useEffect(() => {
          if (questions.length === 0) return;

          const handler = setTimeout(async () => {
            try {
              const stateToSave = { questions, currentQuestionIndex };
              await dbSet(stateToSave);
            } catch (error) {
              console.error("Failed to save state to IndexedDB:", error);
              alert(
                "حدث خطأ غير متوقع أثناء حفظ الاختبار. يرجى التحقق من وحدة التحكم."
              );
            }
          }, 500);

          return () => {
            clearTimeout(handler);
          };
        }, [questions, currentQuestionIndex]);

        const handleUpdateQuestion = (updatedQuestion) => {
          const newQuestions = [...questions];
          newQuestions[currentQuestionIndex] = updatedQuestion;
          setQuestions(newQuestions);
        };

        const handleAddNewQuestion = (index = -1) => {
          const newQuestion = ensureQuestionSanity({ type: "multiple-choice" });
          const newQuestions = [...questions];
          const insertionIndex = index === -1 ? questions.length : index;
          newQuestions.splice(insertionIndex, 0, newQuestion);
          setQuestions(newQuestions);
          setCurrentQuestionIndex(insertionIndex);
        };

        const handleSaveAndAddNew = () => {
          handleAddNewQuestion(currentQuestionIndex + 1);
        };

        const handleSelectQuestion = (index) => {
          setCurrentQuestionIndex(index);
        };

        const handleDeleteQuestion = (index) => {
          if (questions.length <= 1) {
            alert("لا يمكن حذف السؤال الوحيد!");
            return;
          }
          if (window.confirm(`هل أنت متأكد من حذف السؤال رقم ${index + 1}؟`)) {
            const newQuestions = questions.filter((_, i) => i !== index);
            setQuestions(newQuestions);
            if (currentQuestionIndex >= index) {
              setCurrentQuestionIndex(Math.max(0, currentQuestionIndex - 1));
            }
          }
        };

        const handleDuplicateQuestion = (index) => {
          const questionToDuplicate = JSON.parse(
            JSON.stringify(questions[index])
          );
          const newQuestions = [...questions];
          newQuestions.splice(index + 1, 0, questionToDuplicate);
          setQuestions(newQuestions);
          setCurrentQuestionIndex(index + 1);
        };

        const handleQuestionDragStart = (index) => {
          setDraggedIndex(index);
        };

        const handleQuestionDrop = (targetIndex) => {
          if (draggedIndex === null || draggedIndex === targetIndex) {
            setDraggedIndex(null);
            return;
          }

          const newQuestions = [...questions];
          const [draggedItem] = newQuestions.splice(draggedIndex, 1);
          newQuestions.splice(targetIndex, 0, draggedItem);

          let newCurrentIndex = currentQuestionIndex;
          if (currentQuestionIndex === draggedIndex) {
            newCurrentIndex = targetIndex;
          } else if (
            draggedIndex < currentQuestionIndex &&
            targetIndex >= currentQuestionIndex
          ) {
            newCurrentIndex--;
          } else if (
            draggedIndex > currentQuestionIndex &&
            targetIndex <= currentQuestionIndex
          ) {
            newCurrentIndex++;
          }

          setQuestions(newQuestions);
          setCurrentQuestionIndex(newCurrentIndex);
          setDraggedIndex(null);
        };

        const handleImport = () => {
          fileInputRef.current?.click();
        };

        const handleFileChange = (event) => {
          const files = event.target.files;
          if (!files || files.length === 0) return;

          const readPromises = Array.from(files).map((file) => {
            return new Promise((resolve) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const data = JSON.parse(e.target.result);
                  if (!Array.isArray(data)) {
                    alert(`الملف ${file.name} بصيغة غير صحيحة، سيتم تجاهله.`);
                    resolve([]);
                    return;
                  }
                  resolve(data.map((q) => ensureQuestionSanity(q)));
                } catch (err) {
                  alert(`حدث خطأ أثناء تحليل الملف ${file.name}، سيتم تجاهله.`);
                  console.error(`Error parsing ${file.name}:`, err);
                  resolve([]);
                }
              };
              reader.onerror = () => {
                alert(`فشل قراءة الملف ${file.name}.`);
                resolve([]);
              };
              reader.readAsText(file);
            });
          });

          Promise.all(readPromises).then((results) => {
            const allNewQuestions = results.flat();

            if (allNewQuestions.length > 0) {
              setQuestions((prevQuestions) => {
                const isPlaceholder =
                  prevQuestions.length === 1 &&
                  prevQuestions[0].type === "multiple-choice" &&
                  !prevQuestions[0].reading.text &&
                  !prevQuestions[0].reading.image &&
                  !prevQuestions[0].reading.audio &&
                  !prevQuestions[0].question.text &&
                  !prevQuestions[0].question.image &&
                  prevQuestions[0].options.every(
                    (opt) => !opt.text && !opt.image
                  );

                let finalQuestions;
                if (isPlaceholder) {
                  finalQuestions = allNewQuestions;
                  setCurrentQuestionIndex(0);
                } else {
                  finalQuestions = [...prevQuestions, ...allNewQuestions];
                }

                alert(
                  `تم استيراد ${allNewQuestions.length} سؤال بنجاح. العدد الإجمالي الآن هو ${finalQuestions.length} سؤال.`
                );
                return finalQuestions;
              });
            } else {
              alert("لم يتم العثور على أسئلة صالحة في الملفات المحددة.");
            }

            event.target.value = "";
          });
        };

        const handleExport = () => {
          if (questions.length === 0) {
            alert("لا توجد أسئلة لتصديرها!");
            return;
          }
          const dataStr = JSON.stringify(questions, null, 2);
          const blob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "quiz_questions.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        };

        const handleReset = async () => {
          if (
            window.confirm("سيتم مسح جميع الأسئلة الحالية. هل تريد المتابعة؟")
          ) {
            try {
              await dbClear();
              const initialQuestion = ensureQuestionSanity({
                type: "multiple-choice",
              });
              setQuestions([initialQuestion]);
              setCurrentQuestionIndex(0);
            } catch (error) {
              console.error("Failed to reset state:", error);
              alert("فشل مسح الأسئلة.");
            }
          }
        };

        const currentQuestion = questions[currentQuestionIndex] || null;

        const displayedQuestions = React.useMemo(() => {
          return questions
            .map((q, index) => ({ ...q, originalIndex: index })) // Attach original index
            .filter((item) => {
              const typeMatch =
                filterType === "all" || item.type === filterType;
              const searchMatch =
                !searchTerm ||
                stripHtml(item.question.text)
                  .toLowerCase()
                  .includes(searchTerm.toLowerCase());
              return typeMatch && searchMatch;
            });
        }, [questions, filterType, searchTerm]);
        return (
          <div className="min-h-screen text-gray-800 p-4 lg:p-6">
            <div className="container mx-auto max-w-7xl">
              <header className="text-center p-6 bg-white rounded-xl shadow-md mb-6">
                <h1 className="text-3xl lg:text-4xl font-bold text-blue-600">
                  محرر الأسئلة المطور
                </h1>
                <p className="text-gray-600 mt-2">
                  أنشئ وحرر أسئلة اختبارك ثم قم بتصديرها للاستخدام في الاختبار
                  التفاعلي.
                </p>
              </header>

              <div className="flex flex-wrap justify-center gap-3 p-4 bg-white rounded-xl shadow-md mb-6">
                <button
                  onClick={handleImport}
                  className="flex items-center gap-2 bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow"
                >
                  <UploadIcon /> استيراد الأسئلة
                </button>
                <button
                  onClick={handleExport}
                  className="flex items-center gap-2 bg-green-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-600 transition-colors shadow"
                >
                  <DownloadIcon /> تصدير الأسئلة
                </button>
                <button
                  onClick={() => handleAddNewQuestion(-1)}
                  className="flex items-center gap-2 bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors shadow"
                >
                  <PlusIcon /> إضافة سؤال جديد
                </button>
                <button
                  onClick={handleReset}
                  className="flex items-center gap-2 bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors shadow"
                >
                  <TrashIcon /> مسح كل الأسئلة
                </button>
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileChange}
                  accept=".json,application/json"
                  className="hidden"
                  multiple
                />
              </div>

              <main className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-2">
                  {currentQuestion && (
                    <EditorPanel
                      key={currentQuestionIndex}
                      question={currentQuestion}
                      onUpdate={handleUpdateQuestion}
                      questionNumber={currentQuestionIndex + 1}
                      onSaveAndNew={handleSaveAndAddNew}
                    />
                  )}
                </div>
                <div className="lg:col-span-1">
                  <QuestionList
                    questions={displayedQuestions}
                    currentQuestionIndex={currentQuestionIndex}
                    onSelectQuestion={handleSelectQuestion}
                    onDeleteQuestion={handleDeleteQuestion}
                    onDuplicateQuestion={handleDuplicateQuestion}
                    onAddNewQuestion={handleAddNewQuestion}
                    onDragStart={handleQuestionDragStart}
                    onDrop={handleQuestionDrop}
                    filterType={filterType}
                    onFilterChange={setFilterType}
                    searchTerm={searchTerm}
                    onSearchChange={setSearchTerm}
                  />
                </div>
              </main>

              <footer className="mt-8 text-center p-4 bg-white rounded-lg shadow-sm">
                <a
                  href="https://t.me/Interact2030"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-gray-600 hover:text-blue-600 transition-colors text-sm"
                >
                  برمجة و تصميم/ ملتقى التعليم التفاعلي بملتقى معلمي ومعلمات
                  الرياضيات ـ المملكة العربية السعودية
                </a>
              </footer>
            </div>
          </div>
        );
      };

      // ======== Render the App ========
      const rootElement = document.getElementById("root");
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(<App />);
    </script>
  </body>
</html>
